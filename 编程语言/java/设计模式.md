## 评价标准

- 可维护性（maintainability）

  - 面向对象编程提供的封装特性更有利于提高代码的可维护性

- 可读性（readability）

  - 高内聚低耦合

- 可扩展性（extensibility）

  - 基于接口的抽象，可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性。

- 灵活性（flexibility）

  - 在扩展点上添加新的代码即可

  - 功能有底层复用模块

    





## 封装、抽象、继承、多态

- 封装（Encapsulation）
  - 类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节。
  - 对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是访问权限控制。

- 抽象（Abstraction）

  - 如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的
  - 在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性。
  - 抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等

- 继承（Inheritance）

  - 继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。不过，这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。
  - 过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差

- 多态（Polymorphism）

  - 多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。

  - 我们用到了三个语法机制来实现多态。

    - ```java
      
      
      // 编程语言要支持父类对象可以引用子类对象，也就是可以将SortedDynamicArray 传递给 DynamicArray。
      DynamicArray dynamicArray = new SortedDynamicArray();
      
      // 编程语言要支持继承，也就是 SortedDynamicArray 继承了DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray
      public class SortedDynamicArray extends DynamicArray
      
      
      // 子类可以重写（override）父类中的方法
      
      ```

  - 如何利用接口类来实现多态特性

    - Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和LinkedList 都实现了接口类 Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现

  - 多态特性能提高代码的可扩展性和复用性

    - 我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如HashMap，我们只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的可扩展性。
    - 利用多态特性，我们只需要实现一个 print() 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性

  - 除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。





## 面向对象与面向过程

- 什么是面向过程编程与面向过程编程语言？
  - 面向对象编程是一种编程范式或编程风格。支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。
  - 面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。
    面向过程和面向对象最基本的区别就是，代码的组织方式不同。面向过程风格的代码被组织成了一组
  - 方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中







## 哪些代码设计看似是面向对象，实际是面向过程的

- 滥用 getter、setter 方法

  - 虽然我们将字段定义成 private 私有属性，但是提供了 public 的 getter、setter 方法，这就跟将这两个属性定义为 public 公有属性，没有什么两样了。

  - ```java
    // items 属性的 getter 方法，返回的是一个 List集合容器。外部调用者在拿到这个容器之后，是可以操作容器内部数据的，也就是说，外部代码还是能修改 items 中的数据
    private List<ShoppingCartItem> items = new ArrayList<>();
    ```

- 滥用全局变量和全局方法

  - 静态方法一般用来操作静态变量或者外部数据，常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。
  - 一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。
    - 那如何改进 Constants 类的设计呢？我这里有两种思路可以借鉴
      - 第一种是将 Constants 类拆解为功能更加单一的多个类
      - 还有一种我个人觉得更好的设计思路，那就是并不单独地设计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。

- 定义数据和方法分离的类

  - MVC基于贫血模型的开发模式	
    - 这种开发模式是彻彻底底的面向过程编程风格的。这是因为数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的

- 在面向对象编程中，为什么容易写出面向过程风格的代码

  - 总的来说，使用面向对象风格编写的面向过程代码有如下特点：
  - 使用了类，但是
  - 要么完全没有封装（比如数据和操作分离的贫血模式）
  - 要么破坏了封装（比如滥用 getter 或 setter）
  - 要么完全没有抽象（大而全的 Constants 或 Utils 类）
  - 要么封装或抽象不完全（比如类实例化后，或者子类继承后，需要自己管理其内部某些属性或状态）





## 接口与抽象类

- 什么是抽象类和接口？区别在哪里？

  - 抽象类
    - 抽象类不允许被实例化，只能被继承。
    - 抽象类可以包含属性和方法。
    - 子类继承抽象类，必须实现抽象类中的所有抽象方法。
  - 接口
    - 接口不能包含属性（也就是成员变量）。
    - 接口只能声明方法，方法不能包含代码实现。
    - 类实现接口的时候，必须实现接口中声明的所有方法。

- 为什么需要抽象类？它能够解决什么编程问题？

  - public class Logger这个设计思路能用，但是，它显然没有之前通过抽象类的实现思路优雅。Logger 可以被实例化，换句话说，我们可以 new 一个 Logger 出来，在 Logger 中定义一个空的方法，会影响代码的可读性，并且调用空的log() 方法。这也增加了类被误用的风险。
  - 当创建一个新的子类继承 Logger 父类的时候，我们有可能会忘记重新实现 log() 方法。之前基于抽象类的设计思路，编译器会强制要求子类重写 log() 方法，否则会报编译错误。

- 为什么需要接口？它能够解决什么编程问题？

  - 抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。

- 通过抽象类来模拟接口

  - ```java
    // 我们知道类中的方法必须包含实现，这个不符合接口的定义。但是，我们可以让类中的方法抛出 MethodUnSupportedException 异常，来模拟不包含实现的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常。
    
    // 那又如何避免这个类被实例化呢？实际上很简单，我们只需要将这个类的构造函数声明为 protected访问权限就可以了
    	
    public class MockInteface { 
    	 protected MockInteface() {} 
    	 public void funcA() { 
    		 throw new MethodUnSupportedException(); 
    	} 
    }
    ```

- 如何决定该用抽象类还是接口？

  - 如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示 一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。
  - 从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现
  - 接口强调某一方面的统一，抽象强调共性的复用
  - 而java不支持多继承，当想要实现多继承的时候只能使用表示has-a的接口来实现
  - 接口偏向函数式编程的思想，考虑的是行为（动作）的抽象；abstract class是抽象类，更多的是面向对象思想，考虑的是数据的封装





## 基于接口而非实现编程

- 从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”
  - 如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类
- 要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点。
  - 函数的命名不能暴露任何实现细节。
  - 封装具体的实现细节。
  - 为实现类定义抽象的接口。
    - 使用者依赖接口，而不是具体的实现类来编程。







## 多用组合少用继承

- 代码复用我们可以通过组合和委托来实现。

  ```java
  // 接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题
  
  public interface Flyable { 
      void fly()； 
  } 
  
  public class FlyAbility implements Flyable { 
      @Override 
      public void fly() { //... } 
  
      } 
  
      // 省略 Tweetable/TweetAbility/EggLayable/EggLayAbility 
  
      public class Ostrich implements Tweetable, EggLayable {// 鸵鸟 
          private TweetAbility tweetAbility = new TweetAbility(); // 组合 
          private EggLayAbility eggLayAbility = new EggLayAbility(); // 组合 
          //... 省略其他属性和方法... 
          @Override 
          public void tweet() { 
              tweetAbility.tweet(); // 委托 
          } 
  
          @Override 
          public void layEgg() { 
              eggLayAbility.layEgg(); // 委托 
          } 
      }
  
  ```







## 业务开发常用的基于贫血模型的MVC架构违背OOP吗

- 在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。
- 领域驱动设计
  - **主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。**
  - 基于另一个概念的兴起，那就是微服务。领域驱动设计恰好就是用来指导划分服务的。所以，微服务加速了领域驱动设计的盛行。
  - 实际上，基于充血模型的 DDD 开发模式实现的代码，也是按照 MVC 三层架构分层的。它跟基于贫血模型的传统开发模式的区别主要在 Service 层。
    - 在基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中。
    - 在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄。
    - Service 类主要有下面这样几个职责
      - Service 类负责与 Repository 交流
      - Service 类负责跨领域模型的业务聚合功能
      - Service 类负责一些非功能性及与三方系统交互的工作。

单一职责原则

- SOLID 原则
  - 单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母
- 一个类或者模块只负责完成一个职责（或者功能）。
  - 注意，这个原则描述的对象包含两个，一个是类（class），一个是模块（module）
- 内聚和耦合
  - 内聚和耦合其实是对一个意思（即合在一块）从相反方向的两种阐述。
  - 内聚是从功能相关来谈，主张高内聚。把功能高度相关的内容不必要地分离开，就降低了内聚性，成了低内聚。
  - 耦合是从功能无关来谈，主张低耦合。把功能明显无关的内容随意地结合起来，就增加了耦合性，成了高耦合。
  - 所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰



## 如何做到“对扩展开放、修改关闭”

- 开闭原则：基于接口或抽象实现“封闭”，基于实现接口或继承实现“开放”（拓展）。

- 如何理解“对扩展开放、修改关闭”？

  - 如果我们详细表述一下，那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）

- 修改代码就意味着违背开闭原则吗？

  - 给类中添加新的属性和方法，算作“修改”还是“扩展”？
    - 添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为“修改”；但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面，它又可以被认定为“扩展”
    - 如果我们把各个类合起来看作一个“模块”，那模块本身在添加新的功能的时候，完全满足开闭原则。
    - 我们回到这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。
  - 我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。

- 利用多态、依赖注入、基于接口而非实现编程，来实现“对扩展开放、对修改关闭”。

  ```java
  public interface MessageQueue { 
      //... 
  } 
  public class KafkaMessageQueue implements MessageQueue { 
      //... 
  }
  public interface MessageFromatter { 
      //... 
  }
  public class JsonMessageFromatter implements MessageFromatter {
      //...
  }
  public class Demo {  
      private MessageQueue msgQueue; // 基于接口而非实现编程
      public Demo(MessageQueue msgQueue) { // 依赖注入
          this.msgQueue = msgQueue;
      }
      // msgFormatter：多态、依赖注入
      public void sendNotification(Notification notification, MessageFormatter msg） {  
   	//...
      }
  ```

  



## 里式替换（LSP）跟多态有何区别？哪些代码违背了LSP

- 子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。
  - 多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路
  - 而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的
- 哪些代码明显违背了 LSP？
  - 里式替换原则还有另外一个更加能落地、更有指导意义的描述——按照协议来设计
  - 子类违背父类声明要实现的功能
    - 父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序
      的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订
      单排序的。那子类的设计就违背里式替换原则。
  - 子类违背父类对输入、输出、异常的约定
    - 在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。
    - 在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则
    - 在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则
  - 类违背父类注释中所罗列的任何特殊说明
    - 父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余
      额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就
      是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。





## 接口隔离原则

- 接口的调用者或者使用者不应该强迫依赖它不需要的接口。
  - “接口”
    - 一组 API 接口集合
    - 单个 API 接口或函数
    - OOP 中的接口概念
- 一组 API 接口集合
  - 微服务用户系统提供了一组跟用户相关的 API 给其他系统使用，比如：注册、登录、获取用户信息等。
  - 当然，最好的解决方案是从架构设计的层面，通过接口鉴权的方式来限制接口的调用。
  - 如果暂时没有鉴权框架来支持，我们还可以从代码设计的层面，尽量避免接口被误用。
    - 我们参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将RestrictedUserService 只打包提供给后台管理系统来使用。
- 单个 API 接口或函数
  - 为了方便讲解，我都简称为“函数”
  - 那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。
  - 你应该已经发现，接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。
    - 单一职责原则针对的是模块、类、接口的设计
    - 而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。
- OOP 中的接口概念
  - 功能单一的接口，每个类只依赖相关的接口





## 控制反转、依赖反转、依赖注入

- 控制反转（IOC）

  - 这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。
  - 控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。

- 依赖注入（DI）

  - 依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。
    - 用一句话来概括就是：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。
    - 还有继续优化的空间，我们还可以把类定义成接口，基于接口而非实现编程。

- 依赖注入框架（DI Framework）

  - 对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。
    - 这个框架就是“依赖注入框架”。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

- 依赖反转原则（DIP）

  - 有时候也叫依赖倒置原则
    - 高层模块不要依赖低层模块。高层模块和低层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象
      - 所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。
      - 在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计
    - Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在Tomcat 容器下，便可以被 Tomcat 容器调用执行。
      - Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet规范。

- “基于接口而非实现编程”跟“依赖注入”

  - 基于接口而非实现编程是一种设计原则，关注抽象和实现，从细节上的一个函数，到宏观上的系统对接不应该依赖于具体实现而是依赖于抽象的接口，目的是降低耦合性，提高扩展性。
  - 依赖注入是一种具体编程技巧，不从内部建立具体的类依赖而将依赖通过注入或者传参等方式导入，是一种通过抽象降低依赖的具体编码实现

  



## KISS、YAGNI原则

- 如何理解“KISS 原则”？
  - 尽量保持简单
- YAGNI 跟 KISS 说的是一回事吗
  - 实际上，这条原则的核心思想就是：不要做过度设计。
- 奥卡姆剃刀原理
  - 如无必要，勿增实体。





## DRY

- 中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。
- 三种典型的代码重复情况
  - 实现逻辑重复
  - 功能语义重复
  - 代码执行重复
- 代码复用性（Code Reusability）
  - 代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。
  - DRY 原则是一条原则：不要写重复的代码。
- 怎么提高代码复用性？
  - 封装、抽象、继承、多态
  - 减少代码耦合
  - 业务与非业务逻辑分离
  - 通用代码下沉
  - 满足单一职责原则
  - 模块化
  - 应用模板等设计模式





## 迪米特法则（LOD）

- 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。
- 我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。
- 实现高内聚低耦合，但是出发的角度不一样，单一职责是从自身提供的功能出发，迪米特法则是从关系出发，针对接口而非实现编程是使用者的角度，殊途同归





## 针对业务系统的开发，如何做需求分析和设计

- 系统设计
  - 合理地将功能划分到不同模块
    - 是否符合高内聚、低耦合特性来判断
    - 除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息。
      - 比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。
  - 设计模块与模块之间的交互关系
    - 比较常见的系统之间的交互方式有两种，一种是同步接口调用，另一种是利用消息中间件异步调用。第一种方式简单直接，第二种方式的解耦效果更好。
  - 设计模块的接口、数据库、业务模型
    - 接口设计要符合单一职责原则，粒度越小通用性就越好
      - 但是，接口粒度太小也会带来一些问题。比如，一个功能的实现要调用多个小接口，一方面如果接口调用走网络（特别是公网），多次远程接口调用会影响性能；另一方面，本该在一个接口中完成的原子操作，现在分拆成多个小接口来完成，就可能会涉及分布式事务的数据一致性问题（一个接口执行成功了，但另一个接口执行失败了）。
      - 所以，为了兼顾易用性和性能，我们可以借鉴facade（外观）设计模式，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用
    - 业务模型的设计从代码实现角度来说，大部分业务系统的开发都可以分为 Controller、Service、Repository 三层。除此之外，前面我们还提到两种开发模式，基于贫血模型的传统开发模式和基于充血模型的DDD 开发模式。
- 为什么要分 MVC 三层开发
  - 分层能起到代码复用的作用
  - 分层能起到隔离变化的作用
  - 分层能起到隔离关注点的作用
  - 分层能提高代码的可测试性
  - 分层能应对系统的复杂性
    - 拆分有垂直和水平两个方向。水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是这里说的分层。
- VO、BO、Entity 存在的意义是什么？
  - VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。
    - Entity 和 VO 的生命周期是有限的，都仅限在本层范围内。而对应的Repository 层和 Controller 层也都不包含太多业务逻辑，所以也不会有太多代码随意修改数据，即便设计成贫血、定义每个字段的 set 方法，相对来说也是安全的。
    - 不过，Service 层包含比较多的业务逻辑代码，所以 BO 就存在被任意修改的风险了。但是，设计的问题本身就没有最优解，只有权衡。为了使用方便，我们只能做一些妥协，放弃BO 的封装特性，由程序员自己来负责这些数据对象的不被错误使用。







## 针对非业务的通用框架开发，如何做需求分析和设计

- 易用性
  - 框架是否易集成、易插拔、跟业务代码是否松耦合、提供的接口是否够灵活等等
- 性能
  - 一方面，我们希望它是低延迟的，也就是说，功能代码不影响或很少影响接口本身的响应时间；另一方面，我们希望框架本身对内存的消耗不能太大
- 扩展性
  - 之前讲到的扩展是从框架代码开发者的角度来说的。这里所说的扩展是从框架使用者的角度来说的，特指使用者可以在不修改框架源码，甚至不拿到框架源码的情况下，为框架扩展新的功能。这就有点类似给框架开发插件。
- 容错性
  - 容错性这一点也非常重要。不能因为框架本身的异常导致接口请求出错。所以，我们要对框架可能存在的各种异常情况都考虑全面，对外暴露的接口抛出的所有运行时、非运行时异常都进行捕获处理。
- 通用性
  - 还可以适用到其他哪些场景中





## 程序出错：NULL、异常、错误码、空对象

- 错误码

  - Java、Python 等比较新的编程语言中，大部分情况下，我们都用异常来处理函数出错的情况，极少会用到错误码。

- NULL

  - 如果某个函数有可能返回 NULL 值，我们在使用它的时候，忘记了做 NULL 值判断，就有可能会抛出空指针异常（Null Pointer Exception，缩写为 NPE）。
  - 如果我们定义了很多返回值可能为 NULL 的函数，那代码中就会充斥着大量的 NULL 值判断逻辑，一方面写起来比较繁琐，另一方面它们跟正常的业务逻辑耦合在一起，会影响代码的可读性。

- 空对象

  - 当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代NULL 值，来表示不存在的情况。这样，我们在使用函数的时候，就可以不用做 NULL 值判断

- 如何处理函数抛出的异常

  ```java
  // 直接吞掉
  	catch(Exception e)
  // 原封不动地 re-throw
  	public void func() throw Exception
  // 包装成新的异常 re-throw
  	throw new Exception1("..",e)
  ```

  - 如果 func1() 抛出的异常是可以恢复，且 func2() 的调用方并不关心此异常，我们完全可以在 func2() 内将 func1() 抛出的异常吞掉；
  - 如果 func1() 抛出的异常对 func2() 的调用方来说，也是可以理解的、关心的 ，并且在业务概念上有一定的相关性，我们可以选择直接将 func1 抛出的异常 re-throw；
  - 如果 func1() 抛出的异常太底层，对 func2() 的调用方来说，缺乏背景去理解、且业务概念上无关，我们可以将它重新包装成调用方可以理解的新异常，然后 re-throw。

  

  

## 单例模式

- 三个基本要点：一是这个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。

- 处理资源访问冲突

  - 在 UserController 和 OrderController 中，我们分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。

  - 在多线程环境下，如果两个线程同时给同一个共享变量加 1，因为共享变量是竞争资源，所以，共享变量最后的结果有可能并不是加了 2，而是只加了 1。写log.txt 文件也是竞争资源，两个线程同时往里面写数据，就有可能存在互相覆盖的情况。

  - 那如何来解决这个问题呢？我们最先想到的就是通过加锁的方式，通过 synchronized 的关键字synchronized(this)

    - 这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用 log() 函数，会被强制要求顺序执行。但是，不同的对象之间并不共享同一把锁。在不同的线程下，通过不同的对象调用执行 log() 函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题。
    - 要想解决这个问题也不难，我们只需要把对象级别的锁，换成类级别的锁就可以了。让所有的对象都共享同一把锁synchronized(Logger.class)

  - **单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄**（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。

    ```java
    // 我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。
    
    public class Logger{
        private FileWriter writer;
        private static final Logger instance = new Logger();
    }
    ```

- 表示全局唯一类

  - 从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。
    - 比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。
    - 再比如，唯一递增 ID 号码生成器，如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例。

- 如何实现一个单例

  - 需要关注的点

    - 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；
    - 考虑对象创建时的线程安全问题；
    - 考虑是否支持延迟加载；
    - 考虑 getInstance() 性能是否高（是否加锁）。

  - ```java
    // 1. 饿汉式
    // 如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。
    
    // 如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。
    
    // - 使用了 static 修饰了成员变量 instance，所以该变量会在类初始化的过程中被收集进类构造器即 <clinit> 方法中。在多线程场景下，JVM 会保证只有一个线程能执行该类的 <clinit> 方法，其它线程将会被阻塞等待
    // 饿汉模式实现的单例的优点是，可以保证多线程情况下实例的唯一性，而且 getInstance直接返回唯一实例，性能非常高。
    // 然而，在类成员变量比较多，或变量比较大的情况下，这种模式可能会在没有使用类对象的情况下，一直占用堆内存。
    
    public class IdGenerator { 
      private AtomicLong id = new AtomicLong(0);
      private static final IdGenerator instance = new IdGenerator();
      private IdGenerator() {}
      public static IdGenerator getInstance() {
        return instance;
      }
      public long getId() { 
        return id.incrementAndGet();
      }
    }
    
    // 2. 懒汉式
    // 不过懒汉式的缺点也很明显，我们给getInstance()这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。量化一下的话，并发度是1，也就相当于串行操作了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。
    /*
    
    在执行 instance = new Singleton(); 代码时
    - 给 Singleton 分配内存；调用 Singleton 的构造函数来初始化成员变量；将 Singleton 对象指向分配的内存空间（执行完这步 singleton 就为非 null 了）。
    - 如果虚拟机发生了重排序优化，这个时候步骤 3 可能发生在步骤 2 之前。如果初始化线程刚好完成步骤 3，而步骤 2 没有进行时，则刚好有另一个线程到了第一次判断，这个时候判断为非 null，并返回对象使用，这个时候实际没有完成其它属性的构造，因此使用这个属性就很可能会导致异常。在这里Synchronized 只能保证可见性、原子性，无法保证执行的顺序。
    - 这个时候，就体现出 Happens-Before 规则的重要性了
    - volatile 变量的操作指令都不会被重排序。所以使用 volatile 修饰 instance 之后，Double-Check 懒汉单例模式就万无一失了。
    */
    public class IdGenerator { 
      private AtomicLong id = new AtomicLong(0);
      private static IdGenerator instance;
      private IdGenerator() {}
      public static synchronized IdGenerator getInstance() {
        if (instance == null) {
          instance = new IdGenerator();
        }
        return instance;
      }
      public long getId() { 
        return id.incrementAndGet();
      }
    }
    // 3. 双重检测
    // 既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式
    // 在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。
    // 实际上，只有很低版本的 Java 才会有重排序问题。我们现在用的高版本的 Java 已经在JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。
    public class SingletonClass { 
    
      private volatile static SingletonClass instance = null; 
    
      public static SingletonClass getInstance() { 
        if (instance == null) { 
          synchronized (SingletonClass.class) { 
            if(instance == null) { 
              instance = new SingletonClass(); 
            } 
          } 
        } 
        return instance; 
      } 
      private SingletonClass() { 
      } 
    }
    
    // volatile修饰的静态变量访问比较慢，如果不用局部变量则getInstance需要多次访问instance变量，使用局部变量可以有一定的性能提升。
    class Foo {
        private volatile Helper helper;
    
        public Helper getHelper() {
            Helper localRef = helper;
            if (localRef == null) {     
                synchronized (this) {
                    localRef = helper;  
                    if (localRef == null) {
                        helper = localRef = new Helper();
                    }
                }
            }
            return localRef;    
        }
        // other functions and members...
    }
    
    // 4. 静态内部类
    // SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance
    public class IdGenerator { 
      private AtomicLong id = new AtomicLong(0);
      private IdGenerator() {}
    
      private static class SingletonHolder{
        private static final IdGenerator instance = new IdGenerator();
      }
      
      public static IdGenerator getInstance() {
        return SingletonHolder.instance;
      }
     
      public long getId() { 
        return id.incrementAndGet();
      }
    }
    
    // 5. 枚举
    // 这种实现方式通过Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性
    /*
    - 枚举底层实现就是静态内部类
    - 在Java编译后，枚举类中的枚举会被声明为static
    - 最安全的枚举模式，反射和序列化都是单例。
    */
    public enum IdGenerator {
      INSTANCE;
      private AtomicLong id = new AtomicLong(0);
     
      public long getId() { 
        return id.incrementAndGet();
      }
    }
    ```

- 单例存在哪些问题

  - 单例对 OOP 特性的支持不友好

    - IdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的OOP 的抽象特性。	
    - 如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方
    - 一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性。

  - 单例会隐藏类之间的依赖关系

    - 通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。

  - 单例对代码的扩展性不友好

  - 单例对代码的可测试性不友好

  - 单例不支持有参数的构造函数

    - 解决思路是：将参数放到另外一个类中。

    - 里面的值既可以通过静态常量来定义，也可以从配置文件中加载得到。

    - ```java
      public class Config{
          public static final int a=123;
      }
      public class Singleton{
          private static Singeton instance = null;
          private finla int a;
      	
          private Singleton(){
              this.a=Config.a;
          }
      }
      
      ```

- 如何理解单例模式中的唯一性

  - 指进程内只允许创建一个对象，也就是说，单例模式创建的对象是进程唯一的
    - 进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如 user 临时变量、User 对象）。
    - 所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。
  - 实际上，对于 Java 语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class Loader）
    - classloader有两个作用：1. 用于将class文件加载到JVM中；2. 确认每个类应该由哪个类加载器加载，并且也用于判断JVM运行时的两个类是否相等。
    - 双亲委派模型的原理是当一个类加载器接收到类加载请求时，首先会请求其父类加载器加载，每一层都是如此，当父类加载器无法找到这个类时（根据类的全限定名称），子类加载器才会尝试自己去加载。
    - 双亲委派机制鉴定了单例类在进程内唯一

- 如何实现线程唯一的单例

  - 在代码中，我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal底层实现原理也是基于ConcurrentHashMap。

- 如何实现集群环境下的单例

  - 我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。
  - 为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。

- 如何实现一个多例模式

  - “单例”指的是一个类只能创建一个对象，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。多例的实现也比较简单，通过一个Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。

    ```java
    public class Logger { 
        private static final ConcurrentHashMap<String, Logger> instances  = new ConcurrentHashMap<>(); 
        private Logger() {} 
        public static Logger getInstance(String loggerName) {  
            instances.putIfAbsent(loggerName, new Logger()); 
            return instances.get(loggerName); 
        } 
        public void log() { 
            //... 
    
        }  
    }
    
    
    	private static final Map<Long, BackendServer> serverInstances = new HashMap<>(); 
     static { 
         serverInstances.put(1L, new BackendServer(1L, "192.134.22.138:8080")); 
         serverInstances.put(2L, new BackendServer(2L, "192.134.22.139:8080")); 
         serverInstances.put(3L, new BackendServer(3L, "192.134.22.140:8080")); 
     }
    
     public BackendServer getInstance(long serverNo) { 
    	 return serverInstances.get(serverNo); 
     }
    ```

    





## 工厂模式

- 简单工厂（Simple Factory）

  - 大部分工厂类都是以“Factory”这个单词结尾的，但也不是必须的，比如 Java 中的DateFormat、Calender。除此之外，工厂类中创建对象的方法一般都是 create 开头，比如代码中的 createParser()，但有的也命名为 getInstance()、createInstance()、newInstance()，有的甚至命名为 valueOf()（比如 Java String 类的 valueOf() 函数）等等

  - ```java
    // 第一种
    // 尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下是没有问题的。
    public class RuleConfigParserFactory { 
        public static IRuleConfigParser createParser(String configFormat) { 
            IRuleConfigParser parser = null; 
            if ("json".equalsIgnoreCase(configFormat)) { 
                parser = new JsonRuleConfigParser(); 
            } else if ("xml".equalsIgnoreCase(configFormat)) { 
                parser = new XmlRuleConfigParser(); 
            } else if ("yaml".equalsIgnoreCase(configFormat)) { 
                parser = new YamlRuleConfigParser(); 
            } else if ("properties".equalsIgnoreCase(configFormat)) { 
                parser = new PropertiesRuleConfigParser(); 
            }  return parser; 
        } 
    }
    
    // 第二种
    // 在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。
    public class RuleConfigParserFactory{
        private static final Map<String,RuleConfigParser> cachedParsers = new HashMap<>(); 
        static { 
            cachedParsers.put("json", new JsonRuleConfigParser()); 
            cachedParsers.put("yaml", new YamlRuleConfigParser()); 
        }
    
        public static IRuleConfigParserFactory createParser(String configFormat) { 
            if(configForamt == null || configFormat.isEmpty()){
                return null;
            } 
            IRuleConfigParserFactory parser = cachedParsers.get(configFormat.toLowerCase());
            return parser;
        }
    }
    ```

- 工厂方法（Factory Method）

  - 如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。

    - 当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parserfactory 类，并且在RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少

    - ```java
      // 但是实际上存在挺大的问题
      if ("json".equalsIgnoreCase(ruleConfigFileExtension)) { 
          parserFactory = new JsonRuleConfigParserFactory(); 
      } else if ("xml".equalsIgnoreCase(ruleConfigFileExtension)) { 
          parserFactory = new XmlRuleConfigParserFactory(); 
      } else if ("yaml".equalsIgnoreCase(ruleConfigFileExtension)) { 
          parserFactory = new YamlRuleConfigParserFactory(); 
      } else if ("properties".equalsIgnoreCase(ruleConfigFileExtension)) { 
          parserFactory = new PropertiesRuleConfigParserFactory(); 
      } else { 
          throw new InvalidRuleConfigException("Rule config file format is not support");
      }
      ```

  - 我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。

  - ```java
    public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory { 
        @Override 
        public IRuleConfigParser createParser() { 
            return new JsonRuleConfigParser(); 
        } 
    } 
    
    public class RuleConfigParserFactoryMap { //工厂的工厂
        private static final Map<String, IRuleConfigParserFactory> cachedFactories = new HashMap<>(); 
        static { 
            cachedFactories.put("json", new JsonRuleConfigParserFactory()); 
            cachedFactories.put("xml", new XmlRuleConfigParserFactory()); 
        } 
    
        public static IRuleConfigParserFactory getParserFactory(String type) { 
            if (type == null || type.isEmpty()) { 
                return null; 
            } 
            IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase); 
            return parserFactory; 
        } 
    }
    ```

- 什么时候该用工厂方法模式，而非简单工厂模式

  - 当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候
    - 我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至过于复杂。
    - 而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。
  - 复杂度无法被消除，只能被转移
    - 不用工厂模式，if-else 逻辑、创建逻辑和业务代码耦合在一起
    - 简单工厂是将不同创建逻辑放到一个工厂类中，if-else 逻辑在这个工厂类中
    - 工厂方法是将不同创建逻辑放到不同工厂类中，先用一个工厂类的工厂来来得到某个工厂，再用这个工厂来创建，if-else 逻辑在工厂类的工厂中

- 使用静态工厂方法替代的是使用构造函数，之所以用静态方法，是因为它比构造函数具有以下优势

  - 构造函数的名字无意义，方法的名字包含更多有用信息
  - 构造函数只能返回当前Class类型对象，而方法可以返回当前类型对象、当前类型的子类对象，也可以返回基础数据类型
  - 如果创建过程很复杂，那么方法可以把很多不应该由构造函数处理的过程放在方法中，让构造函数只处理初始化成员的工作，职责更单一。
  - 方法可以控制生成对象的个数(单例，多例等)

- 工厂模式和 DI 容器有何区别？

  - 实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。
    - 工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。
    - 除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理

- 核心工厂类设计

  - 如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的
  - BeansFactory 类中的 createBean() 函数是一个递归函数。当构造函数的参数是 ref 类型时，会递归地创建 ref 属性指向的对象。如果我们在配置文件中错误地配置了对象之间的依赖关系，导致存在循环依赖，那 BeansFactory 的 createBean() 函数是否会出现堆栈溢出？又该如何解决这个问题呢？
    - Spring解决循环依赖的办法是多级缓存，分阶段初始化。
      - setter注入：根据BenDefinition创建的bean可以是未完成的bean，就是说bean里面的属性可以是没有填充过的，这个时候bean依然能创建成功，之后属性，postConstruct、InitializingBean、init-method完成之后才能算是一个完整的bean，所以即使出现循环依赖也能解决。
        - 单例情况:Bean A和Bean B之间的循环依赖关系迫使其中一个Bean在完全初始化之前被注入另一个Bean
        - 多例不能解决循环依赖，因为多例不需要缓存
      - 构造器循环依赖
        - 构造器注入的循环依赖是无法解决的，只能抛出bean创建异常(引发BeanCurrentlyInCreationException)使容器无法启动

  

  

  

## 建造者模式

- 为什么需要建造者模式？
  - 如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。
  - 除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。
  - 如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在ResourcePoolConfig 类中暴露 set() 方法。
- 我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。
- 与工厂模式有何区别？
  - 实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。
  - 顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。

## 职责链模式

- 模板模式、策略模式、职责链模式这三种模式具有相同的作用：复用和扩展，在实际的项目开发中比较常用，特别是框架开发中，我们可以利用它们来提供框架的扩展点，能够让框架的使用者在不修改框架源码的情况下，基于扩展点定制化框架的功能。

- 将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。

  - 在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过A处理器处理，然后再把请求传递给B处理器，B处理器处理完后再传递给C处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。

- 职责链模式有多种实现方式，我们这里介绍两种比较常用的。

  - 第一种实现方式如下所示。其中，Handler是所有处理器类的抽象父类，handle()是抽象方法。每个具体的处理器类（HandlerA、HandlerB）的handle()函数的代码结构类似，如果它能处理该请求，就不继续往下传递；如果不能处理，则交由后面的处理器来处理（也就是调用successor.handle()）。HandlerChain是处理器链，从数据结构的角度来看，它就是一个记录了链头、链尾的链表

  - ```java
    public abstract class Handler {
      protected Handler successor = null;
    
      public void setSuccessor(Handler successor) {
        this.successor = successor;
      }
    
      public abstract void handle();
    }
    
    public class HandlerA extends Handler {
      @Override
      public boolean handle() {
        boolean handled = false;
        //...
        if (!handled && successor != null) {
          successor.handle();
        }
      }
    }
    
    public class HandlerB extends Handler {
      @Override
      public void handle() {
        boolean handled = false;
        //...
        if (!handled && successor != null) {
          successor.handle();
        } 
      }
    }
    
    public class HandlerChain {
      private Handler head = null;
      private Handler tail = null;
    
      public void addHandler(Handler handler) {
        handler.setSuccessor(null);
    
        if (head == null) {
          head = handler;
          tail = handler;
          return;
        }
    
        tail.setSuccessor(handler);
        tail = handler;
      }
    
      public void handle() {
        if (head != null) {
          head.handle();
        }
      }
    }
    
    // 使用举例
    public class Application {
      public static void main(String[] args) {
        HandlerChain chain = new HandlerChain();
        chain.addHandler(new HandlerA());
        chain.addHandler(new HandlerB());
        chain.handle();
      }
    }
    
    // 我们对代码进行重构，利用模板模式，将调用successor.handle()的逻辑从具体的处理器类中剥离出来，放到抽象父类中。这样具体的处理器类只需要实现自己的业务逻辑就可以了。重构之后的代码如下所示：
    
    public abstract class Handler {
      protected Handler successor = null;
    
      public void setSuccessor(Handler successor) {
        this.successor = successor;
      }
    
      public final void handle() {
        boolean handled = doHandle();
        if (successor != null && !handled) {
          successor.handle();
        }
      }
    
      protected abstract boolean doHandle();
    }
    
    public class HandlerA extends Handler {
      @Override
      protected boolean doHandle() {
        boolean handled = false;
        //...
        return handled;
      }
    }
    
    public class HandlerB extends Handler {
      @Override
      protected boolean doHandle() {
        boolean handled = false;
        //...
        return handled;
      }
    }
    
    // HandlerChain和Application代码不变
    ```

- 我们再来看第二种实现方式，代码如下所示。这种实现方式更加简单。HandlerChain类用数组而非链表来保存所有的处理器，并且需要在HandlerChain的handle()函数中，依次调用每个处理器的handle()函数。

  ```java
  public interface IHandler {
    boolean handle();
  }
  
  public class HandlerA implements IHandler {
    @Override
    public boolean handle() {
      boolean handled = false;
      //...
      return handled;
    }
  }
  
  public class HandlerB implements IHandler {
    @Override
    public boolean handle() {
      boolean handled = false;
      //...
      return handled;
    }
  }
  
  public class HandlerChain {
    private List<IHandler> handlers = new ArrayList<>();
  
    public void addHandler(IHandler handler) {
      this.handlers.add(handler);
    }
  
    public void handle() {
      for (IHandler handler : handlers) {
        boolean handled = handler.handle();
        if (handled) {
          break;
        }
      }
    }
  }
  
  // 使用举例
  public class Application {
    public static void main(String[] args) {
      HandlerChain chain = new HandlerChain();
      chain.addHandler(new HandlerA());
      chain.addHandler(new HandlerB());
      chain.handle();
    }
  }
  ```

- 应用场景举例

  - 对于支持UGC（User Generated Content，用户生成内容）的应用（比如论坛）来说，用户生成的内容（比如，在论坛中发表的帖子）可能会包含一些敏感词（比如涉黄、广告、反动等词汇）。针对这个应用场景，我们就可以利用职责链模式来过滤这些敏感词。

  - 对于包含敏感词的内容，我们有两种处理方式，一种是直接禁止发布，另一种是给敏感词打马赛克（比如，用***替换敏感词）之后再发布。第一种处理方式符合GoF给出的职责链模式的定义，第二种处理方式是职责链模式的变体。

  - ```java
    public interface SensitiveWordFilter {
      boolean doFilter(Content content);
    }
    
    public class SexyWordFilter implements SensitiveWordFilter {
      @Override
      public boolean doFilter(Content content) {
        boolean legal = true;
        //...
        return legal;
      }
    }
    
    // PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似
    
    public class SensitiveWordFilterChain {
      private List<SensitiveWordFilter> filters = new ArrayList<>();
    
      public void addFilter(SensitiveWordFilter filter) {
        this.filters.add(filter);
      }
    
      // return true if content doesn't contain sensitive words.
      public boolean filter(Content content) {
        for (SensitiveWordFilter filter : filters) {
          if (!filter.doFilter(content)) {
            return false;
          }
        }
        return true;
      }
    }
    
    public class ApplicationDemo {
      public static void main(String[] args) {
        SensitiveWordFilterChain filterChain = new SensitiveWordFilterChain();
        filterChain.addFilter(new AdsWordFilter());
        filterChain.addFilter(new SexyWordFilter());
        filterChain.addFilter(new PoliticalWordFilter());
    
        boolean legal = filterChain.filter(new Content());
        if (!legal) {
          // 不发表
        } else {
          // 发表
        }
      }
    }
    ```

  - 应用设计模式主要是为了应对代码的复杂性，让其满足开闭原则，提高代码的扩展性。这里应用职责链模式也不例外。

  - **首先，我们来看，职责链模式如何应对代码的复杂性。**

    将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法。**应用职责链模式，我们把各个敏感词过滤函数继续拆分出来，设计成独立的类，进一步简化了SensitiveWordFilter类，让SensitiveWordFilter类的代码不会过多，过复杂。**

  - **其次，我们再来看，职责链模式如何让代码满足开闭原则，提高代码的扩展性。**

    当我们要扩展新的过滤算法的时候，比如，我们还需要过滤特殊符号，按照非职责链模式的代码实现方式，我们需要修改SensitiveWordFilter的代码，违反开闭原则。不过，这样的修改还算比较集中，也是可以接受的。而**职责链模式的实现方式更加优雅，只需要新添加一个Filter类，并且通过addFilter()函数将它添加到FilterChain中即可，其他代码完全不需要修改。**

    不过，你可能会说，即便使用职责链模式来实现，当添加新的过滤算法的时候，还是要修改客户端代码（ApplicationDemo），这样做也没有完全符合开闭原则。

    实际上，细化一下的话，我们可以把上面的代码分成两类：框架代码和客户端代码。其中，ApplicationDemo属于客户端代码，也就是使用框架的代码。除ApplicationDemo之外的代码属于敏感词过滤框架代码。

    **假设敏感词过滤框架并不是我们开发维护的，而是我们引入的一个第三方框架，我们要扩展一个新的过滤算法，不可能直接去修改框架的源码。这个时候，利用职责链模式就能达到开篇所说的，在不修改框架源码的情况下，基于职责链模式提供的扩展点，来扩展新的功能。换句话说，我们在框架这个代码范围内实现了开闭原则。**

    除此之外，利用职责链模式相对于不用职责链的实现方式，还有一个好处，那就是配置过滤算法更加灵活，可以只选择使用某几个过滤算法。

- 框架中常用的过滤器、拦截器是如何实现的？

  - 今天，我们就通过Servlet Filter、Spring Interceptor这两个Java开发中常用的组件，来具体讲讲它在框架开发中的应用。

  - Servlet Filter

    - Servlet Filter是Java Servlet规范中定义的组件，翻译成中文就是过滤器，它可以实现对HTTP请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。因为它是Servlet规范的一部分，所以，只要是支持Servlet的Web容器（比如，Tomcat、Jetty等），都支持过滤器功能。为了帮助你理解，我画了一张示意图阐述它的工作原理，如下所示。

    - 在实际项目中，我们该如何使用Servlet Filter呢？我写了一个简单的示例代码，如下所示。添加一个过滤器，我们只需要定义一个实现javax.servlet.Filter接口的过滤器类，并且将它配置在web.xml配置文件中。Web容器启动的时候，会读取web.xml中的配置，创建过滤器对象。当有请求到来的时候，会先经过过滤器，然后才由Servlet来处理。
      - ```java
        
        
        
        
        
        
        public class LogFilter implements Filter {
          @Override
          public void init(FilterConfig filterConfig) throws ServletException {
            // 在创建Filter时自动调用，
            // 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）
          }
        
          @Override
          public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
            System.out.println("拦截客户端发送来的请求.");
            chain.doFilter(request, response);
            System.out.println("拦截发送给客户端的响应.");
          }
        
          @Override
          public void destroy() {
            // 在销毁Filter时自动调用
          }
        }
        
        // 在web.xml配置文件中如下配置：
        <filter>
          <filter-name>logFilter</filter-name>
          <filter-class>com.xzg.cd.LogFilter</filter-class>
        </filter>
        <filter-mapping>
            <filter-name>logFilter</filter-name>
            <url-pattern>/*</url-pattern>
        </filter-mapping>
        ```

    - Servlet只是一个规范，并不包含具体的实现，所以，Servlet中的FilterChain只是一个接口定义。具体的实现类由遵从Servlet规范的Web容器来提供，比如，ApplicationFilterChain类就是Tomcat提供的FilterChain的实现类，源码简化后如下所示。

      ```java
      public final class ApplicationFilterChain implements FilterChain {
        private int pos = 0; //当前执行到了哪个filter
        private int n; //filter的个数
        private ApplicationFilterConfig[] filters;
        private Servlet servlet;
        
        @Override
        public void doFilter(ServletRequest request, ServletResponse response) {
          if (pos < n) {
            ApplicationFilterConfig filterConfig = filters[pos++];
            Filter filter = filterConfig.getFilter();
            filter.doFilter(request, response, this);
          } else {
            // filter都处理完毕后，执行servlet
            servlet.service(request, response);
          }
        }
        
        public void addFilter(ApplicationFilterConfig filterConfig) {
          for (ApplicationFilterConfig filter:filters)
            if (filter==filterConfig)
               return;
      
          if (n == filters.length) {//扩容
            ApplicationFilterConfig[] newFilters = new ApplicationFilterConfig[n + INCREMENT];
            System.arraycopy(filters, 0, newFilters, 0, n);
            filters = newFilters;
          }
          filters[n++] = filterConfig;
        }
      }
      ```

      ApplicationFilterChain中的doFilter()函数的代码实现比较有技巧，实际上是一个递归调用。你可以用每个Filter（比如LogFilter）的doFilter()的代码实现，直接替换ApplicationFilterChain的第12行代码，一眼就能看出是递归调用了。我替换了一下，如下所示。

      ```java
        @Override
        public void doFilter(ServletRequest request, ServletResponse response) {
          if (pos < n) {
            ApplicationFilterConfig filterConfig = filters[pos++];
            Filter filter = filterConfig.getFilter();
            //filter.doFilter(request, response, this);
            //把filter.doFilter的代码实现展开替换到这里
            System.out.println("拦截客户端发送来的请求.");
            chain.doFilter(request, response); // chain就是this
            System.out.println("拦截发送给客户端的响应.")
          } else {
            // filter都处理完毕后，执行servlet
            servlet.service(request, response);
          }
        }
      ```

      这样实现主要是为了在一个doFilter()方法中，支持双向拦截，既能拦截客户端发送来的请求，也能拦截发送给客户端的响应

- Spring Interceptor

  - 它们不同之处在于，Servlet Filter是Servlet规范的一部分，实现依赖于Web容器。Spring Interceptor是Spring MVC框架的一部分，由Spring MVC框架来提供实现。客户端发送的请求，会先经过Servlet Filter，然后再经过Spring Interceptor，最后到达具体的业务代码中。我画了一张图来阐述一个请求的处理流程，具体如下所示。

    ![img](http://reader.epubee.com/books/mobile/92/921ca80baa5b392ad2eb98941323da84/Image00056.jpg)

  - LogFilter对请求和响应的拦截是在doFilter()一个函数中实现的，而LogInterceptor对请求的拦截在preHandle()中实现，对响应的拦截在postHandle()中实现。

    ```java
    public class LogInterceptor implements HandlerInterceptor {
    
      @Override
      public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("拦截客户端发送来的请求.");
        return true; // 继续后续的处理
      }
    
      @Override
      public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("拦截发送给客户端的响应.");
      }
    
      @Override
      public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("这里总是被执行.");
      }
    }
    
    //在Spring MVC配置文件中配置interceptors
    <mvc:interceptors>
       <mvc:interceptor>
           <mvc:mapping path="/*"/>
           <bean class="com.xzg.cd.LogInterceptor" />
       </mvc:interceptor>
    </mvc:interceptors>
    ```

- Spring Interceptor底层是如何实现的。

  - 当然，它也是基于职责链模式实现的。其中，HandlerExecutionChain类是职责链模式中的处理器链。它的实现相较于Tomcat中的ApplicationFilterChain来说，逻辑更加清晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。
  - 在Spring框架中，DispatcherServlet的doDispatch()方法来分发请求，它在真正的业务逻辑执行前后，执行HandlerExecutionChain中的applyPreHandle()和applyPostHandle()函数，用来实现拦截的功能。





## 代理模式

- 代理模式的原理解析

  - 它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能

  - ```java
    // 代理类 UserControllerProxy和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码
    
    // 因为原始类和代理类实现相同的接口，是基于接口而非实现编程，将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码
    @Override
    public UserVo login(String telephone, String password){
    	xxx
    	UserVo userVo = userController.login(telephone, password);
    	xxx
    }
    }
    
    IUserController userController = new UserControllerProxy(new UserController())
    ```

- 动态代理的原理解析

  - 所谓动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。那如何实现动态代理呢？
  - 动态代理中所说的"动态",是针对使用Java代码实际编写了代理类的"静态"代理而言的,它的优势不在于省去了编写代理类那一点编码工作量,而是实现了可以在原始类和接口还未知的时候,就确定了代理类的行为,当代理类与原始类脱离直接联系后,就可以很灵活的重用于不同的应用场景之中
  - 实际上，Spring AOP底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring为这些类创建动态代理对象，并在JVM中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的

- Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）

  - java中,动态代理的实现基于字节码生成技术(代码里就是newProxyInstance片段),可以在jvm运行时动态生成和加载字节码,类似的技术还有asm,cglib,javassist,平时编译java用的javac命令就是字节码生成技术的"老祖宗"

  - ```java
    // 其中，MetricsCollectorProxy作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类。
    
    public class MetricsCollectorProxy {
      private MetricsCollector metricsCollector;
    
      public MetricsCollectorProxy() {
        this.metricsCollector = new MetricsCollector();
      }
    
      public Object createProxy(Object proxiedObject) {
        Class<?>[] interfaces = proxiedObject.getClass().getInterfaces();
        DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);
        return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);
      }
    
      private class DynamicProxyHandler implements InvocationHandler {
        private Object proxiedObject;
    
        public DynamicProxyHandler(Object proxiedObject) {
          this.proxiedObject = proxiedObject;
        }
    
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
          long startTimestamp = System.currentTimeMillis();
          Object result = method.invoke(proxiedObject, args);
          long endTimeStamp = System.currentTimeMillis();
          long responseTime = endTimeStamp - startTimestamp;
          String apiName = proxiedObject.getClass().getName() + ":" + method.getName();
          RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);
          metricsCollector.recordRequest(requestInfo);
          return result;
        }
      }
    }
    
    //MetricsCollectorProxy使用举例
    MetricsCollectorProxy proxy = new MetricsCollectorProxy();
    IUserController userController = (IUserController) proxy.createProxy(new UserController());
    
    ```

- 代理模式的应用场景

  - 业务系统的非功能性需求开发
    - 代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发
    - 这部分工作都是可以在 Spring AOP 切面中完成的
  - 代理模式在 RPC、缓存中的应用
    - GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节







## 装饰器模式

- 它的代码结构跟桥接模式非常相似，不过，要解决的问题却大不相同。

- 从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。

  - 第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。

    - ```java
      // 我们对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。
      
      InputStream in = new FileInputStream("/user/test.txt"); 
      InputStream bin = new BufferedInputStream(in); 
      DataInputStream din = new DataInputStream(bin); 
      int data = din.readInt();
      ```

  - 第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点

    - 就拿比较相似的代理模式和装饰器模式来说，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能

- 代理在结构上类似装饰者，但是目的不同

  - 我们可以说代理是一个黑盒子，而装饰器是一个白盒子
  - Decorator关注为对象动态的添加功能, Proxy关注对象的信息隐藏及访问控制.
    - Decorator体现多态性, Proxy体现封装性
    - 对于**添加缓存**这个应用场景使用哪种模式，要看设计者的意图，如果设计者不需要用户关注是否使用缓存功能，要隐藏实现细节，也就是说用户只能看到和使用代理类，那么就使用proxy模式；反之，如果设计者需要用户自己决定是否使用缓存的功能，需要用户自己新建原始对象并动态添加缓存功能，那么就使用decorator模式。
    - 缓存这件事一般都是高度抽象，全业务通用，基本不会改动的东西，所以一般也是采用代理模式，让业务开发从缓存代码的重复劳动中解放出来。但如果当前业务的缓存实现需要特殊化定制，需要揉入业务属性，那么就该采用装饰者模式。因为其定制性强，其他业务也用不着，而且业务是频繁变动的，所以改动的可能也大，相对于动代，装饰者在调整（修改和重组）代码这件事上显得更灵活
  - Proxy和Decorator之间的区别在于Proxy 限制了客户端。装饰器没有。代理可以通过控制对功能的访问来限制客户端的操作。装饰器的作用相反：装饰器以客户端可见的方式增强其功能。







## 观察者模式

- UserController 还是耦合了很多跟观察者模式相关的非业务代码，比如创建线程池、注册 Observer。为了让UserController 更加聚焦在业务功能上，你有什么重构的建议吗？

  - 代理模式，使用一个代理类专门来处理EventBus相关逻辑，将业务与非业务逻辑分离

- **异步非阻塞观察者模式的简易实现**

  - 我们有两种实现方式。其中一种是：在每个 handleRegSuccess() 函数中创建一个新的线 程执行代码逻辑；另一种是：在 UserController 的 register() 函数中使用线程池来执行每 个观察者的 handleRegSuccess() 函数。

  - ```java
    // 第一种实现方式，其他类代码不变，就没有再重复罗列
    public class RegPromotionObserver implements RegObserver {
      private PromotionService promotionService; // 依赖注入
    
      @Override
      public void handleRegSuccess(long userId) {
        Thread thread = new Thread(new Runnable() {
          @Override
          public void run() {
            promotionService.issueNewUserExperienceCash(userId);
          }
        });
        thread.start();
      }
    }
    
    // 第二种实现方式，其他类代码不变，就没有再重复罗列
    public class UserController {
      private UserService userService; // 依赖注入
      private List<RegObserver> regObservers = new ArrayList<>();
      private Executor executor;
    
      public UserController(Executor executor) {
        this.executor = executor;
      }
    
      public void setRegObservers(List<RegObserver> observers) {
        regObservers.addAll(observers);
      }
    
      public Long register(String telephone, String password) {
        //省略输入参数的校验代码
        //省略userService.register()异常的try-catch代码
        long userId = userService.register(telephone, password);
    
        for (RegObserver observer : regObservers) {
          executor.execute(new Runnable() {
            @Override
            public void run() {
              observer.handleRegSuccess(userId);
            }
          });
        }
    
        return userId;
      }
    }
    ```

  - 对于第一种实现方式，频繁地创建和销毁线程比较耗时，并且并发线程数无法控制，创建过 多的线程会导致堆栈溢出。第二种实现方式，尽管利用了线程池解决了第一种实现方式的问 题，但线程池、异步执行逻辑都耦合在了 register() 函数中，增加了这部分业务代码的维护 成本

  - 如果我们的需求更加极端一点，需要在同步阻塞和异步非阻塞之间灵活切换，那就要不停地 修改 UserController 的代码。除此之外，如果在项目中，不止一个业务模块需要用到异步 非阻塞观察者模式，那这样的代码实现也无法做到复用

  - 我们知道，框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业 务代码，让程序员聚焦业务开发。

- EventBus 框架

  - EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框 架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。其中， Google Guava EventBus 就是一个比较著名的 EventBus 框架，它不仅仅支持异步非阻塞 模式，同时也支持同步阻塞模式

  - ```java
    public class UserController {
      private UserService userService; // 依赖注入
    
      private EventBus eventBus;
      private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE = 20;
    
      public UserController() {
        //eventBus = new EventBus(); // 同步阻塞模式
        eventBus = new AsyncEventBus(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); // 异步非阻塞模式
      }
    
      public void setRegObservers(List<Object> observers) {
        for (Object observer : observers) {
          eventBus.register(observer);
        }
      }
    
      public Long register(String telephone, String password) {
        //省略输入参数的校验代码
        //省略userService.register()异常的try-catch代码
        long userId = userService.register(telephone, password);
    
        eventBus.post(userId);
    
        return userId;
      }
    }
    
    public class RegPromotionObserver {
      private PromotionService promotionService; // 依赖注入
    
      @Subscribe
      public void handleRegSuccess(long userId) {
        promotionService.issueNewUserExperienceCash(userId);
      }
    }
    
    public class RegNotificationObserver {
      private NotificationService notificationService;
    
      @Subscribe
      public void handleRegSuccess(long userId) {
        notificationService.sendInboxMessage(userId, "...");
      }
    }
    ```

  - 利用 EventBus 框架实现的观察者模式，跟从零开始编写的观察者模式相比，从大的流程上 来说，实现思路大致一样，都需要定义 Observer，并且通过 register() 函数注册Observer，也都需要通过调用某个函数（比如，EventBus 中的 post() 函数）来给 Observer 发送消息（在 EventBus 中消息被称作事件 event）。 

  - 但在实现细节方面，它们又有些区别。基于 EventBus，我们不需要定义 Observer 接口， 任意类型的对象都可以注册到 EventBus 中，通过 @Subscribe 注解来标明类中哪个函数 可以接收被观察者发送的消息。 

  - Guava EventBus 对外暴露的所有可调用接口，都封装在 EventBus 类中。其中， EventBus 实现了同步阻塞的观察者模式，AsyncEventBus 继承自 EventBus，提供了异步 非阻塞的观察者模式。

    - ```java
      EventBus eventBus = new EventBus(); // 同步阻塞模式
      EventBus eventBus = new AsyncEventBus(Executors.newFixedThreadPool(8))；// 异步阻塞模式
      
      ```

    - EventBus 类提供了 register() 函数用来注册观察者。具体的函数定义如下所示。它可以接 受任何类型（Object）的观察者。而在经典的观察者模式的实现中，register() 函数必须接 受实现了同一 Observer 接口的类对象。 

    - 相对于 register() 函数，unregister() 函数用来从 EventBus 中删除某个观察者。

    - EventBus 类提供了 post() 函数，用来给观察者发送消息

      - 跟经典的观察者模式的不同之处在于，当我们调用 post() 函数发送消息的时候，并非把消 息发送给所有的观察者，而是发送给可匹配的观察者。所谓可匹配指的是，能接收的消息类 型是发送消息（post 函数定义中的 event）类型的父类。

    - EventBus 通过 @Subscribe 注解来标明，某个函数能接收哪种类型的消息

      - 当通过 register() 函数将 DObserver 类对象注册到 EventBus 的时候，EventBus 会根据 @Subscribe 注解找到 f1() 和 f2()，并且将两个函数能接收的消息类型记录下来（PMsg- \>f1，QMsg->f2）。当我们通过 post() 函数发送消息（比如 QMsg 消息）的时候， EventBus 会通过之前的记录（QMsg->f2），调用相应的函数（f2）。 

- 实现一个EventBus框架

  - EventBus中两个核心函数register()和post()的实现原理

    - 最关键的一个数据结构是Observer注册表，记录了消息类型和可接收消息函数的对应关系。
    - 当调用register()函数注册观察者的时候，EventBus通过解析@Subscribe注解，生成Observer注册表。
    - 当调用post()函数发送消息的时候，EventBus通过注册表找到相应的可接收消息的函数，然后通过Java的反射语法来动态地创建对象、执行函数。
    - 对于同步阻塞模式，EventBus在一个线程内依次执行相应的函数。
    - 对于异步非阻塞模式，EventBus通过一个线程池来执行相应的函数。

  - Subscribe是一个注解，用于标明观察者中的哪个函数可以接收消息。

    - ```java
      @Retention(RetentionPolicy.RUNTIME)
      @Target(ElementType.METHOD)
      @Beta
      public @interface Subscribe {}
      ```

  - ObserverAction类用来表示@Subscribe注解的方法，其中，target表示观察者类，method表示方法。它主要用在ObserverRegistry观察者注册表中

  - ObserverRegistry类就是前面讲到的Observer注册表，是最复杂的一个类，框架中几乎所有的核心逻辑都在这个类中。这个类大量使用了Java的反射语法，不过代码整体来说都不难理解，其中，一个比较有技巧的地方是CopyOnWriteArraySet的使用。

    - ```java
      public class ObserverRegistry {
        private ConcurrentMap<Class<?>, CopyOnWriteArraySet<ObserverAction>> registry = new ConcurrentHashMap<>();
      
        public void register(Object observer) {
          Map<Class<?>, Collection<ObserverAction>> observerActions = findAllObserverActions(observer);
          for (Map.Entry<Class<?>, Collection<ObserverAction>> entry : observerActions.entrySet()) {
            Class<?> eventType = entry.getKey();
            Collection<ObserverAction> eventActions = entry.getValue();
            CopyOnWriteArraySet<ObserverAction> registeredEventActions = registry.get(eventType);
            if (registeredEventActions == null) {
              registry.putIfAbsent(eventType, new CopyOnWriteArraySet<>());
              registeredEventActions = registry.get(eventType);
            }
            registeredEventActions.addAll(eventActions);
          }
        }
      
        public List<ObserverAction> getMatchedObserverActions(Object event) {
          List<ObserverAction> matchedObservers = new ArrayList<>();
          Class<?> postedEventType = event.getClass();
          for (Map.Entry<Class<?>, CopyOnWriteArraySet<ObserverAction>> entry : registry.entrySet()) {
            Class<?> eventType = entry.getKey();
            Collection<ObserverAction> eventActions = entry.getValue();
            if (postedEventType.isAssignableFrom(eventType)) {
              matchedObservers.addAll(eventActions);
            }
          }
          return matchedObservers;
        }
      
        private Map<Class<?>, Collection<ObserverAction>> findAllObserverActions(Object observer) {
          Map<Class<?>, Collection<ObserverAction>> observerActions = new HashMap<>();
          Class<?> clazz = observer.getClass();
          for (Method method : getAnnotatedMethods(clazz)) {
            Class<?>[] parameterTypes = method.getParameterTypes();
            Class<?> eventType = parameterTypes[0];
            if (!observerActions.containsKey(eventType)) {
              observerActions.put(eventType, new ArrayList<>());
            }
            observerActions.get(eventType).add(new ObserverAction(observer, method));
          }
          return observerActions;
        }
      
        private List<Method> getAnnotatedMethods(Class<?> clazz) {
          List<Method> annotatedMethods = new ArrayList<>();
          for (Method method : clazz.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Subscribe.class)) {
              Class<?>[] parameterTypes = method.getParameterTypes();
              Preconditions.checkArgument(parameterTypes.length == 1,
                      "Method %s has @Subscribe annotation but has %s parameters."
                              + "Subscriber methods must have exactly 1 parameter.",
                      method, parameterTypes.length);
              annotatedMethods.add(method);
            }
          }
          return annotatedMethods;
        }
      }
      ```

- EventBus实现的是阻塞同步的观察者模式。看代码你可能会有些疑问，这明明就用到了线程池Executor啊。实际上，MoreExecutors.directExecutor()是Google Guava提供的工具类，看似是多线程，实际上是单线程。之所以要这么实现，主要还是为了跟AsyncEventBus统一代码逻辑，做到代码复用。

  - ```java
    public class EventBus {
      private Executor executor;
      private ObserverRegistry registry = new ObserverRegistry();
    
      public EventBus() {
        this(MoreExecutors.directExecutor());
      }
    
      protected EventBus(Executor executor) {
        this.executor = executor;
      }
    
      public void register(Object object) {
        registry.register(object);
      }
    
      public void post(Object event) {
        List<ObserverAction> observerActions = registry.getMatchedObserverActions(event);
        for (ObserverAction observerAction : observerActions) {
          executor.execute(new Runnable() {
            @Override
            public void run() {
              observerAction.execute(event);
            }
          });
        }
      }
    }
    
    ```

- 有了EventBus，AsyncEventBus的实现就非常简单了。为了实现异步非阻塞的观察者模式，它就不能再继续使用

  - MoreExecutors.directExecutor()了，而是需要在构造函数中，由调用者注入线程池。

  ```java
  public class AsyncEventBus extends EventBus {
    public AsyncEventBus(Executor executor) {
      super(executor);
    }
  }
  
  ```



## 模板模式

- 模板模式主要是用来解决复用和扩展两个问题。
  - 模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。
  - 这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。
  - 模板模式有两大作用：复用和扩展。其中，复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。
- InputStream部分相关代码中，read()函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了read()，只是参数跟模板方法不同。
- 在Java AbstractList类中，addAll()函数可以看作模板方法，add()是子类需要重写的方法，尽管没有声明为abstract的，但函数实现直接抛出了UnsupportedOperationException异常。前提是，如果子类不重写是不能使用的。
- 相对于普通的函数调用，回调是一种双向调用关系。A类事先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来又调用A，这种调用机制就叫作“回调”。
  - 回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现，回调比模板模式更加灵活。



## 策略模式

- 概述

  - 最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。
  - 定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。
  - 我们知道，工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分。

- 如何利用策略模式避免分支判断

  - 本质上都是借助“查表法”，根据 type 查表
  - 但是，如果业务场景需要每次都创建不同的策略对象，我们就要用另外一种工厂类的实现方式了。
    - 这种实现方式相当于把原来的 if-else 分支逻辑，从 OrderService 类中转移到了工厂类中，实际上并没有真正将它移除。
  - 在策略工厂类中，如果每次都要返回新的策略对象，我们还是需要在工厂类中编写 if-else 分支判断逻辑，那这个问题该如何解决呢？
    - 可以用查表法，只不过存储的不再是实例，而是class，使用时获取对应的class，再通过反射创建实例
    - 或者我们通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类；策略工厂类读取配置文件或者搜索被 annotation 标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象；当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用 annotation 标注即可。

- 策略的定义

  - 策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类

- 策略的创建

  - 因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中

  - ```java
    public class StrategyFactory {
      private static final Map<String, Strategy> strategies = new HashMap<>();
    
      static {
        strategies.put("A", new ConcreteStrategyA());
        strategies.put("B", new ConcreteStrategyB());
      }
    
      public static Strategy getStrategy(String type) {
        if (type == null || type.isEmpty()) {
          throw new IllegalArgumentException("type should not be empty.");
        }
        return strategies.get(type);
      }
    }
    ```
  ```
    
  - 一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用 getStrategy() 的时候，都创建一个新的策略对象。针对这种情况，我们可以使用上面这种工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回
  
  - 相反，如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象（return new ConcreteStrategyA）
  
    - ```java
      public class StrategyFactory {
        public static Strategy getStrategy(String type) {
          if (type == null || type.isEmpty()) {
            throw new IllegalArgumentException("type should not be empty.");
          }
      
          if (type.equals("A")) {
            return new ConcreteStrategyA();
          } else if (type.equals("B")) {
            return new ConcreteStrategyB();
          }
      
          return null;
        }
      }
  ```

  ​    

- 策略的使用

  - 最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景
  
- 这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略
  
  - ```java
    // 策略接口：EvictionStrategy
    // 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...
    // 策略工厂：EvictionStrategyFactory
    
    public class UserCache {
      private Map<String, User> cacheData = new HashMap<>();
      private EvictionStrategy eviction;
    
      public UserCache(EvictionStrategy eviction) {
        this.eviction = eviction;
      }
    
      //...
    }
    
    // 运行时动态确定，根据配置文件的配置决定使用哪种策略
    public class Application {
      public static void main(String[] args) throws Exception {
        EvictionStrategy evictionStrategy = null;
        Properties props = new Properties();
        props.load(new FileInputStream("./config.properties"));
        String type = props.getProperty("eviction_type");
        evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);
        UserCache userCache = new UserCache(evictionStrategy);
        //...
      }
    }
    
    // 非运行时动态确定，在代码中指定使用哪种策略
    public class Application {
      public static void main(String[] args) {
        //...
        EvictionStrategy evictionStrategy = new LruEvictionStrategy();
        UserCache userCache = new UserCache(evictionStrategy);
        //...
      }
    }
    ```
  
- 如何利用策略模式避免分支判断

  - 我们先通过一个例子来看下，if-else或switch-case分支判断逻辑是如何产生的。具体的代码如下所示。在这个例子中，我们没有使用策略模式，而是将策略的定义、创建、使用直接耦合在一起。

    ```java
    public class OrderService {
      public double discount(Order order) {
        double discount = 0.0;
        OrderType type = order.getType();
        if (type.equals(OrderType.NORMAL)) { // 普通订单
          //...省略折扣计算算法代码
        } else if (type.equals(OrderType.GROUPON)) { // 团购订单
          //...省略折扣计算算法代码
        } else if (type.equals(OrderType.PROMOTION)) { // 促销订单
          //...省略折扣计算算法代码
        }
        return discount;
      }
    }
    ```

    如何来移除掉分支判断逻辑呢？那策略模式就派上用场了。我们使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。具体的代码如下所示：

    ```java
    // 策略的定义
    public interface DiscountStrategy {
      double calDiscount(Order order);
    }
    // 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...
    
    // 策略的创建
    public class DiscountStrategyFactory {
      private static final Map<OrderType, DiscountStrategy> strategies = new HashMap<>();
    
      static {
        strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());
        strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());
        strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());
      }
    
      public static DiscountStrategy getDiscountStrategy(OrderType type) {
        return strategies.get(type);
      }
    }
    
    // 策略的使用
    public class OrderService {
      public double discount(Order order) {
        OrderType type = order.getType();
        DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);
        return discountStrategy.calDiscount(order);
      }
    }
    ```

    重构之后的代码就没有了if-else分支判断语句了。实际上，这得益于策略工厂类。在工厂类中，我们用Map来缓存策略，根据type直接从Map中获取对应的策略，从而避免if-else分支判断逻辑。等后面讲到使用状态模式来避免分支判断逻辑的时候，你会发现，它们使用的是同样的套路。本质上都是借助“查表法”，根据type查表（代码中的strategies就是表）替代根据type分支判断。

    但是，如果业务场景需要每次都创建不同的策略对象，我们就要用另外一种工厂类的实现方式了。具体的代码如下所示：

    ```java
    public class DiscountStrategyFactory {
      public static DiscountStrategy getDiscountStrategy(OrderType type) {
        if (type == null) {
          throw new IllegalArgumentException("Type should not be null.");
        }
        if (type.equals(OrderType.NORMAL)) {
          return new NormalDiscountStrategy();
        } else if (type.equals(OrderType.GROUPON)) {
          return new GrouponDiscountStrategy();
        } else if (type.equals(OrderType.PROMOTION)) {
          return new PromotionDiscountStrategy();
        }
        return null;
      }
    }
    ```

# **Java JDK**





## **工厂模式在** **Calendar** **类中的应用**

- Calendar 类提供了大量跟日期相关的功能代码，同时，又提供了一个 getInstance() 工厂方法，用来根据不同的 TimeZone 和 Locale 创建不同的 Calendar 子类对象。





## **建造者模式在** **Calendar** **类中的应用**

- 建一个对象最常用的方式是，使用new关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢

  - 假设有这样一道设计面试题：我们需要定义一个资源池配置类ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个ResourcePoolConfig类

  - 现在，ResourcePoolConfig只有4个可配置项，对应到构造函数中，也只有4个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了8个、10个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。

    - 解决这个问题的办法你应该也已经想到了，那就是用set()函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项name是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项maxTotal、maxIdle、minIdle都不是必填的，所以我们通过set()函数来设置，让使用者自主选择填写或者不填写。

    - 如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。

      - 我们刚刚讲到，name是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过set()方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。
      - 除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了maxTotal、maxIdle、minIdle其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle和minIdle要小于等于maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。
      - 如果我们希望ResourcePoolConfig类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在ResourcePoolConfig类中暴露set()方法。

    - 为了解决这些问题，建造者模式就派上用场了。

      - 我们可以把校验逻辑放置到Builder类中，先创建建造者，并且通过set()方法设置建造者的变量值，然后在使用build()方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把ResourcePoolConfig的构造函数改为private私有权限。这样我们就只能通过建造者来创建ResourcePoolConfig类对象。并且，ResourcePoolConfig没有提供任何set()方法，这样我们创建出来的对象就是不可变对象了。

      - ```JAVA
        public class ResourcePoolConfig {
          private String name;
          private int maxTotal;
          private int maxIdle;
          private int minIdle;
        
          private ResourcePoolConfig(Builder builder) {
            this.name = builder.name;
            this.maxTotal = builder.maxTotal;
            this.maxIdle = builder.maxIdle;
            this.minIdle = builder.minIdle;
          }
          //...省略getter方法...
        
          //我们将Builder类设计成了ResourcePoolConfig的内部类。
          //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。
          public static class Builder {
            private static final int DEFAULT_MAX_TOTAL = 8;
            private static final int DEFAULT_MAX_IDLE = 8;
            private static final int DEFAULT_MIN_IDLE = 0;
        
            private String name;
            private int maxTotal = DEFAULT_MAX_TOTAL;
            private int maxIdle = DEFAULT_MAX_IDLE;
            private int minIdle = DEFAULT_MIN_IDLE;
        
            public ResourcePoolConfig build() {
              // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等
              if (StringUtils.isBlank(name)) {
                throw new IllegalArgumentException("...");
              }
              if (maxIdle > maxTotal) {
                throw new IllegalArgumentException("...");
              }
              if (minIdle > maxTotal || minIdle > maxIdle) {
                throw new IllegalArgumentException("...");
              }
        
              return new ResourcePoolConfig(this);
            }
        
            public Builder setName(String name) {
              if (StringUtils.isBlank(name)) {
                throw new IllegalArgumentException("...");
              }
              this.name = name;
              return this;
            }
        
            public Builder setMaxTotal(int maxTotal) {
              if (maxTotal <= 0) {
                throw new IllegalArgumentException("...");
              }
              this.maxTotal = maxTotal;
              return this;
            }
        
            public Builder setMaxIdle(int maxIdle) {
              if (maxIdle < 0) {
                throw new IllegalArgumentException("...");
              }
              this.maxIdle = maxIdle;
              return this;
            }
        
            public Builder setMinIdle(int minIdle) {
              if (minIdle < 0) {
                throw new IllegalArgumentException("...");
              }
              this.minIdle = minIdle;
              return this;
            }
          }
        }
        
        // 这段代码会抛出IllegalArgumentException，因为minIdle>maxIdle
        ResourcePoolConfig config = new ResourcePoolConfig.Builder()
                .setName("dbconnectionpool")
                .setMaxTotal(16)
                .setMaxIdle(10)
                .setMinIdle(12)
                .build();
        
        实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后set的方式，那就会导致在第一个set之后，对象处于无效状态。具体代码如下所示：
        
        Rectangle r = new Rectange(); // r is invalid
        r.setWidth(2); // r is invalid
        r.setHeight(3); // r is valid
        ```

        

- 建 造者模式有两种实现方法，一种是单独定义一个 Builder 类，另一种是将 Builder 实现为原始类的内部类。Calendar 就采用了第二种实现思路。

- 工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。 
  
  - 粗看 Calendar 的 Builder 类的 build() 方法，你可能会觉得它有点像工厂模式。你的感觉 没错，前面一半代码确实跟 getInstance() 工厂方法类似，根据不同的 type 创建了不同的 Calendar 子类。实际上，后面一半代码才属于标准的建造者模式，根据 setXXX() 方法设置的参数，来定制化刚刚创建的 Calendar 子类对象。





## **装饰器模式在** **Collections** **类中的应用**

- 装饰器模式中的装饰器类是对原始类功能的增强。
  - Collections 类是一个集合容器的工具类，提供了很多静态方法，用来创建各种集合容器， 比如通过 unmodifiableColletion() 静态方法，来创建 UnmodifiableCollection 类对象。而这些容器类中的 UnmodifiableCollection 类、CheckedCollection 和SynchronizedCollection 类，就是针对 Collection 类的装饰器类。 
  - UnmodifiableCollection 的构造函数接收一个 Collection 类对象，然后对其所有的函数进行了包裹（Wrap）：重新实现（比如 add() 函数）或者简单封装（比如 stream() 函数）。而简单的接口实现或者继承，并不会如此来实现UnmodifiableCollection 类。所以，从代码实现的角度来说，UnmodifiableCollection 类是典型的装饰器类





## **模板模式在** **Collections** **类中的应用**

- 策略、模板、职责链三个模式常用在框架的设计中，提供框架的扩展点，让框架使用者，在不修改框架源码的情况下，基于扩展点定制化框架的功能。Java 中的Collections 类的 sort() 函数就是利用了模板模式的这个扩展特性。

  ```java
  // Collections.sort() 实现了对集合的排序。为了扩展性，它将其中“比较大小”这部分逻辑，委派给用户来实现。如果我们把比较大小这部分逻辑看作整个排序逻辑的其中一个步骤，那我们就可以把它看作模板模式。
  public static class ScoreDescComparator implements Comparator<Student> 
  ```

  



## **单例模式在** **Runtime** **类中的应用**

- 每个 Java 应用在运行时会启动一个 JVM 进程，每个 JVM 进程都只对应一个 Runtime 实 例，用于查看 JVM 状态以及控制 JVM 行为。进程内唯一，所以比较适合设计为单例。在编程的时候，我们不能自己去实例化一个 Runtime 对象，只能通过 getRuntime() 静态方法来获得。
  - 它使用了最简单的饿汉式的单例实现方式







## **其他模式在** **JDK** **中的应用汇总**

- 迭代器模式：Iterator 迭代器的实现
- 职责链模式：Java Servlet 中的 Filter 就是通过职责链来实现的， 实际上，拦截器、过滤器这些功能绝大部分都是采用职责链模式来实现的
- 享元模式： Integer 类中的 -128~127 之间的整型对象是可以复用的， String 类型中的常量字符串也是可以复用的。这些都是享元模式的经典应用。
- 模板模式：AbstractList







# Sping 

Sping 背后蕴含的一些经典设计思想，主要有：约定优于配置，低侵入、松耦合，模块化、轻量级，再封装、再抽象。这些设计思想都比较通用，我们可以借鉴到其他框架的开发中。 





## **模板模式在** **Spring** **中的应用**

- 利用模板模式，Spring 能让用户定制 Bean 的创建过程。
  - spring Bean 的创建过程，可以大致分为两大步：对象的创建和对象的初始化。
- 实际上，Spring 针对对象的初始化过程，还做了进一步的细化，将它拆分成了三个小步骤：初始化前置操作、初始化、初始化后置操作
  - 对象的初始化有两种实现方式
    - 类中自定义一个初始化函数，并且通过配置文件，显式地告知 Spring，哪个函数是初始化函数。
    - 类实现 Initializingbean 接口。这个接口包含一个固定的初始化函数定义（afterPropertiesSet() 函数）。Spring 在初始 化 Bean 的时候，可以直接通过 bean.afterPropertiesSet() 的方式，调用 Bean 对象上的 这个函数，而不需要使用反射来调用了。
  - 初始化的前置和后置操作，定义在接口 BeanPostProcessor 中。
  - 我们只需要定义一个实现了 BeanPostProcessor 接口的处理器类，并在配置文件中像配置 普通 Bean 一样去配置就可以了。Spring 中的 ApplicationContext 会自动检测在配置文 件中实现了 BeanPostProcessor 接口的所有 Bean，并把它们注册到 BeanPostProcessor处理器列表中。在 Spring 容器创建 Bean 的过程中，Spring 会逐一去调用这些处理器。 
- 实际上，这里的模板模式的实现，并不是标准的抽象类的实现方式，而是有点类似 Callback 回调的实现方式，也就是将要执行的函数封装成对象（比如，初始化方法封装成 InitializingBean 对象），传递给模板（BeanFactory）来执行。





## **适配器模式在** **Spring** **中的应用**

- 定义一个 Controller
  - 方法一：通过@Controller、@RequestMapping来定义
  - 方法二：实现Controller接口 + xml配置文件:配置DemoController与URL的对应关系
  - 方法三：实现Servlet接口 + xml配置文件:配置DemoController类与URL的对应关系
  - 在应用启动的时候，Spring 容器会加载这些 Controller 类，并且解析出 URL 对应的处理函数，封装成 Handler 对象，存储到 HandlerMapping 对象中。当有请求到来的时候，DispatcherServlet 从 HanderMapping 中，查找请求 URL 对应的 Handler，然后调用执行 Handler 对应的函数代码，最后将执行结果返回给客户端。 
- 适配器其中一个作用是“统一多个类的接口设计”
  - Spring 定义了统一的接口 HandlerAdapter，并且对每种 Controller 定义了对应的适配器类。
  - 在 DispatcherServlet 类中，我们就不需要区分对待不同的 Controller 对象了，统一调用HandlerAdapter 的 handle() 函数就可以了。







## **策略模式在** **Spring** **中的应用**

- 策略模式包含三部分，策略的定义、创建和使用。接
  - 对应到 Spring 源码，AopProxy 是策略接口，JdkDynamicAopProxy、CglibAopProxy 是两个实现了 AopProxy 接口的策略类	
  - 在策略模式中，策略的创建一般通过工厂方法来实现。对应到 Spring 源码，AopProxyFactory 是一个工厂类接口，DefaultAopProxyFactory 是一个默认的工厂类，用来创建 AopProxy 对象。
  - 策略模式的典型应用场景，一般是通过环境变量、状态值、计算结果等动态地决定使用哪个策略。





## **组合模式在** **Spring** **中的应用**

- Spring Cache 提供了一套抽象的 Cache 接口。使用它我们能够统一不同缓存实现（Redis、Google Guava…）的不同的访问方式。

- 组合模式主要应用在能表示成树形结构的一组数据上

  - 树中的结点分为叶子节点和中间节点两类。对应到 Spring 源码，EhCacheManager、 

    SimpleCacheManager、NoOpCacheManager、RedisCacheManager 等表示叶子节点，CompositeCacheManager 表示中间节点。

  - CompositeCacheManger 的代码中， getCache()、getCacheNames() 两个函数的实现都用到了递归。这正是树形结构最能发挥优势的地方

    



## **装饰器模式在** **Spring** **中的应用**

- 缓存一般都是配合数据库来使用的。如果写缓存成功，但数据库事务回滚了，那 缓存中就会有脏数据。为了解决这个问题，我们需要将缓存的写操作和数据库的写操作，放到同一个事务中，要么都成功，要么都失败。

  - 实现这样一个功能，Spring 使用到了装饰器模式。TransactionAwareCacheDecorator 增加了对事务的支持，在事务提交、回滚的时候分别对 Cache 的数据进行处理

  - ```java
    // TransactionAwareCacheDecorator 实现 Cache 接口，并且将所有的操作都委托给 
    targetCache 来实现，对其中的写操作添加了事务功能。
    
    private final Cache targetCache; 
    ```

    





## **工厂模式在** **Spring** **中的应用**

- 创建 Bean 的方式

  - ```java
    // 使用构造函数来创建Bean 
    <bean id="student" class="com.xzg.cd.Student"> 
    <constructor-arg name="id" value="1"/> 
    <constructor-arg name="name" value="wangzheng"/> 
    </bean> 
    // 使用无参构造函数+setter方法来创建Bean 
    <bean id="student" class="com.xzg.cd.Student">
    <property name="id" value="1"></property> 
    <property name="name" value="wangzheng"></property>
    </bean> 
    
    // ------
    
    public class StudentFactory { 
    	private static Map<Long, Student> students = new HashMap<>(); 
    	static{ 
    		map.put(1, new Student(1,"wang")); 
    		map.put(2, new Student(2,"zheng")); 
    		map.put(3, new Student(3,"xzg")); 
    }
    	public static Student getStudent(long id){ 
    		return students.get(id); 
    }
    }
    // 通过工厂方法getStudent(2)来创建BeanId="zheng""的Bean
    <bean id="zheng" class="com.xzg.cd.StudentFactory" factory-method="getStudent">
    <constructor-arg value="2"></constructor-arg>
        </bean>
    ```



## **职责链模式在** **Spring** **中的应用**

Spring Interceptor底层是如何实现的。

- 当然，它也是基于职责链模式实现的。其中，HandlerExecutionChain类是职责链模式中的处理器链。它的实现相较于Tomcat中的ApplicationFilterChain来说，逻辑更加清晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。
- 在Spring框架中，DispatcherServlet的doDispatch()方法来分发请求，它在真正的业务逻辑执行前后，执行HandlerExecutionChain中的applyPreHandle()和applyPostHandle()函数，用来实现拦截的功能。



## **其他模式在** **Spring** **中的应用**

- 单例模式有很多弊端，比如单元测试不友好等。应对策略就是通过 IOC 容器来管理对象，通过 IOC 容器来实现对象的唯一性的控制。实际上，这样实现的单例并非真正的单例，它的唯一性的作用范围仅仅在同一个 IOC 容器内。 
- 职责链模式在 Spring 中的应用是拦截器（Interceptor），代理模式经典应用是 AOP。



# Mybatis





## 利用职责链与代理模式实现MyBatis Plugin

- 实际上，MyBatis Plugin 跟 Servlet Filter、Spring Interceptor 的功能是类似的，都是在不需要修改原有流程代码的情况下，拦截某些方法调用，在拦截的方法调用的前后，执行一些额外的代码逻辑。
  - 它们的唯一区别在于拦截的位置是不同的。
    - Servlet Filter 主要拦截Servlet 请求
    - Spring Interceptor 主要拦截 Spring 管理的 Bean 方法（比如 Controller类的方法等）
    - 而 MyBatis Plugin 主要拦截的是 MyBatis 在执行 SQL 的过程中涉及的一些方法。
  - 只需要定义一个 SqlCostTimeInterceptor 类，让它实现 MyBatis 的 Interceptor 接口，并且，在 MyBatis 的全局配置文件中，简单声明一下这个插件就可以了。
- @Intercepts 注解
  - @Intercepts 注解又可以嵌套@Signature 注解。一个 @Signature 注解标明一个要拦截的目标方法。
  - @Signature 注解包含三个元素：type、method、args。其中，type 指明要拦截的类、 method 指明方法名、args 指明方法的参数列表。通过指定这三个元素，我们就能完全确定一个要拦截的方法。 
    - MyBatis 底层是通过 Executor 类来执行 SQL 的。
      - Executor 类会创建StatementHandler、ParameterHandler、ResultSetHandler 三个对象
      - 首先使用 ParameterHandler 设置 SQL 中的占位符参数，然后使用 StatementHandler 执行SQL 语句，最后使用 ResultSetHandler 封装执行结果。
      - 所以，我们只需要拦截Executor、ParameterHandler、ResultSetHandler、StatementHandler 这几个类的方 法，基本上就能满足我们对整个 SQL 执行流程的拦截了。
- MyBatis Plugin 的设计与实现
  - 借助动态代理来实现职责链的
  - 职责链模式的实现一般包含处理器（Handler）和处理器链（HandlerChain）两部分。
    - 这两个部分对应到 Servlet Filter 的源码就是 Filter和 FilterChain，对应到 Spring Interceptor 的源码就是 HandlerInterceptor 和HandlerExecutionChain，对应到 MyBatis Plugin 的源码就是 Interceptor 和InterceptorChain。
    - 除此之外，MyBatis Plugin 还包含一个非常重要的类：Plugin。它用来生成被拦截对象的动态代理。 
  - Interceptor 类中 intecept() 和 plugin() 函数，以及 InterceptorChain 类中的 pluginAll() 函数，是最核心的三个函数
    - 解析完配置文件之后，所有的 Interceptor 都加载到了 InterceptorChain 中
    - 四个类对象的创建过程都调用了 InteceptorChain 的pluginAll() 方法，嵌套调用 InterceptorChain 上每个 Interceptor 的 plugin() 方法。plugin()是一个接口方法（不包含实现代码），需要由用户给出具体的实现代码。在之前的例子中，SQLTimeCostInterceptor 的 plugin() 方法通过直接调用 Plugin 的 wrap() 方法来实现
    - Plugin 是借助 Java InvocationHandler 实现的动态代理类。用来代理给 target对象添加 Interceptor 功能。其中，要代理的 target 对象就是 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这四个类的对象。wrap()静态方法是一个工具函数，用来生成 target 对象的动态代理对象。 
      - 它对同一个目标对象嵌套多次代理（也就是 InteceptorChain 中的 pluginAll() 函数要执行的任务）。每个代理对象（Plugin 对象）代理一个拦截器（Interceptor 对象）功能。
      - 当执行 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这四个类上的某个方法的时候，MyBatis 会嵌套执行每层代理对象（Plugin 对象）上的 invoke()方法。而 invoke() 方法会先执行代理对象中的 interceptor 的 intecept() 函数，然后再执行被代理对象上的方法









## **SqlSessionFactoryBuilder**

- 大量的 build() 重载函数
- 从建造者模式的设计初衷上来看，SqlSessionFactoryBuilder 虽然带有 Builder 后缀，但不要被它的名字所迷惑，它并不是标准的建造者模式。
- 实际上，SqlSessionFactoryBuilder 设计的初衷只不过是为了简化开发。因为构建SqlSessionFactory 需要先构建 Configuration，而构建 Configuration 是非常复杂的，需要做很多工作，比如配置的读取、解析、创建 n 多对象等。为了将构建SqlSessionFactory 的过程隐藏起来，对程序员透明，MyBatis 就设计了SqlSessionFactoryBuilder 类封装这些构建细节。 





## SqlSessionFactory

- 实际上，它也并不是标准的工厂模式。
- 重载多个 openSession() 函数
- SqlSessionFactory 是一个接口，DefaultSqlSessionFactory 是它唯一的实现类
  - 虽然设计思路基本一致，但一个叫 xxxBuilder（SqlSessionFactoryBuilder），一个叫xxxFactory（SqlSessionFactory）。而且，叫 xxxBuilder 的也并非标准的建造者模式，叫 xxxFactory 的也并非标准的工厂模式。所以，我个人觉得，MyBatis 对这部分代码的设计还是值得优化的。
  - 实际上，这两个类的作用只不过是为了创建 SqlSession 对象，没有其他作用。所以，我更建议参照 Spring 的设计思路，把 SqlSessionFactoryBuilder 和 SqlSessionFactory 的逻辑，放到一个叫“ApplicationContext”的类中。让这个类来全权负责读入配置文件，创建 Congfiguration，生成 SqlSession。 





## **BaseExecutor**

- Executor 本身是一个接口；BaseExecutor 是一个抽象类，实现了 Executor 接口；而 BatchExecutor、SimpleExecutor、ReuseExecutor 三个类继承 BaseExecutor 抽象类。 
- 模板模式基于继承来实现代码复用。如果抽象类中包含模板方法，模板方法调用有待子类实现的抽象方法，那这一般就是模板模式的代码实现。而且，在命名上，模板方法与抽象方法一般是一一对应的，抽象方法在模板方法前面多一个“do”，比如，在 BaseExecutor 类中，其中一个模板方法叫 update()，那对应的抽象方法就叫 doUpdate()。 









## **SqlNode**

- 动态 SQL
- 解释器模式在解释语法规则的时候，一般会把规则分割成小的单元，特别是 可以嵌套的小单元，针对每个小单元来解析，最终再把解析结果合并在一起。这里也不例外。MyBatis 把每个语法小单元叫 SqlNode。







## **ErrorContext**

- 在 MyBatis 中，ErrorContext 这个类就是标准单例的变形：线程唯一的单例

- 它基于 Java 中的 ThreadLocal 来实现。

  





## **Cache**

- 在 MyBatis 中，缓存功能由接口 Cache 定义。PerpetualCache 类是最基础的缓存类，是 一个大小无限的缓存。除此之外，MyBatis 还设计了 9 个包裹 PerpetualCache 类的装饰器类，用来实现功能增强。
- 之所以 MyBatis 采用装饰器模式来实现缓存功能，是因为装饰器模式采用了组合，而非继承，更加灵活，能够有效地避免继承关系的组合爆炸。







## **PropertyTokenizer**

- Mybatis 的 PropertyTokenizer 类实现了 Java Iterator 接口，是一个迭代器，用来对配置属性进行解析。
- PropertyTokenizer 类也并非标准的迭代器类。它将配置的解析、解析之后的元 素、迭代器，这三部分本该放到三个类中的代码，都耦合在一个类中







## **Log**

- Slf4j 框架为了统一各个不同的日志框架（Log4j、 JCL、Logback 等），提供了一套统一的日志接口。不过，MyBatis 并没有直接使用 Slf4j提供的统一日志规范，而是自己又重复造轮子，定义了一套自己的日志访问接口。

- 针对 Log 接口，MyBatis 还提供了各种不同的实现类，分别使用不同的日志框架来实现Log 接口。

- 在适配器模式中，传递给适配器构造函数的是被适配的类对象，而这里是 clazz（相当于日志名称 name），所以，从代码实现上来讲，它并非标准的适配器模式。但是，从应用场景上来看，这里确实又起到了适配的作用，是典型的适配器模式的应用场景。 

  - ```java
    public Log4jImpl(String clazz) { 
    	log = Logger.getLogger(clazz); 
    }
    ```

    




































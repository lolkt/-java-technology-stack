# 工作区和GOPATH

- 3 个环境变量
  - GOROOT：Go 语言安装根目录的路径，也就是 GO 语言的安装路径。
  - GOPATH：若干工作区目录的路径。是我们自己定义的工作空间。
    - 你可以把 GOPATH 简单理解成 Go 语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，**每个目录都代表 Go 语言的一个工作区**（workspace）。
    - 我们需要利于这些工作区，去放置 Go 语言的源码文件（source file），以及安装（install）后的归档文件（archive file，也就是以“.a”为扩展名的文件）和可执行文件（executable file）
      - 归档文件在Linux下就是扩展名是.a的文件，也就是archive文件，这是程序编译后生成的静态库文件
  - GOBIN：GO 程序生成的可执行文件（executable file）的路径

- Go 语言源码的组织方式
  - 与许多编程语言一样，Go 语言的源码也是以代码包为基本组织单位的
  - 在工作区中，一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相对路径。
  - 所以说，Go 语言源码的组织方式就是以环境变量 GOPATH、工作区、src 目录和代码包为主线的。一般情况下，Go 语言的源码文件都需要被存放在环境变量 GOPATH 包含的某个工作区（目录）中的 src 目录下的某个代码包（目录）中。
  - 某个工作区的 src 子目录下的源码文件在安装后一般会被放置到当前工作区的 pkg 子目录下对应的目录中，或者被直接放置到该工作区的 bin 子目录中





# 库源码文件

- 库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体，这些程序实体可以被其他代码使用（只要遵从 Go 语言规范的话）。

  - 在 Go 语言中，程序实体是变量、常量、函数、结构体和接口的统称。

  - 为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致。

    - ```go
      // 故意让声明的包名与其所在的目录的名称不同
      package lib5
       
      import "fmt"
       
      // 首字母大写的Hello
      func Hello(name string) {
      	fmt.Printf("Hello, %s!\n", name)
      }
      
      ---
      
      ./demo5.go:5:2: imported and not used: "puzzlers/article3/q2/lib" as lib5
      ./demo5.go:16:2: undefined: lib
      ```

    - 有两个方式可以使上述构建成功完成。我在这里选择把 demo5_lib.go 文件中的代码包声明语句改为`package lib`。

- 什么样的程序实体才可以被当前包外的代码引用

  - 名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。
  - 包名不需要和其所在的文件夹名相同
  - 通过名称，Go 语言自然地把程序实体的访问权限划分为了包级私有的和公开的。对于包级私有的程序实体，即使你导入了它所在的代码包也无法引用到它。





# 程序实体

- var name string

  - 这里利用了 Go 语言自身的类型推断，而省去了对该变量的类型的声明。
    - 类型推断是一种编程语言在编译期自动解释表达式类型的能力
    - 表达式类型就是对表达式进行求值后得到结果的类型。Go 语言中的类型推断是很简约的，这也是 Go 语言整体的风格。
    - 它只能用于对变量或常量的初始化。

- name := flag.String("name", "everyone", "The greeting object.")

  - 对`flag.String`函数的调用其实就是一个调用表达式，而这个表达式的类型是`*string`，即字符串的指针类型。
  - 这也是调用`flag.String`函数后得到结果的类型。随后，Go 语言把这个调用了`flag.String`函数的表达式类型，直接作为了变量`name`的类型，这就是“推断”一词所指代的操作了。
  - var name string ---基于类型推断->var name ="aaa" or name := "aaa"

- Go 语言的类型推断可以带来哪些好处

  - ```go
    package main
     
    import (
    	"flag"
    	"fmt"
    )
     
    func main() {
    	var name = getTheFlag()
    	flag.Parse()
    	fmt.Printf("Hello, %v!\n", *name)
    }
     
    func getTheFlag() *string {
    	return flag.String("name", "everyone", "The greeting object.")
    }
    ```

  - 这样一来，`var name =`右边的表达式，可以变为针对`getTheFlag`函数的调用表达式了。这实际上是对“声明并赋值`name`变量的那行代码”的重构。

  - 我们不显式地指定变量`name`的类型，使得它可以被赋予任何类型的值。也就是说，变量`name`的类型可以在其初始化时，由其他程序动态地确定。

  - Go 语言是静态类型的，所以一旦在初始化变量时确定了它的类型，之后就不可能再改变。这就避免了在后面维护程序时的一些问题。另外，请记住，**这种类型的确定是在编译期完成的，因此不会对程序的运行效率产生任何影响。**

  - **如果只用一两句话回答这个问题的话，我想可以是这样的**：Go 语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序的运行效率。

- 变量的重声明
  
  - 通过使用它，我们可以对同一个代码块中的变量进行重声明。
    
    - 在 Go 语言中，**代码块**一般就是一个由花括号括起来的区域，里面可以包含表达式和语句。
    - 这种代码块的划分，也间接地决定了程序实体的作用域。
    
  - 变量重声明的前提条件如下
  
    - 由于变量的类型在其初始化时就已经确定了，所以**对它再次声明时赋予的类型必须与其原本的类型相同**，否则会产生编译错误。
    - **变量的重声明只可能发生在某一个代码块中。**如果与当前的变量重名的是外层代码块中的变量，当前变量覆盖外层变量。
    - **变量的重声明只有在使用短变量声明时才会发生**，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字`var`的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了。
    - **被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量**。这时我们才可以说对其中的旧变量进行了重声明。
  
  - ```go
    var err error
    n, err := io.WriteString(os.Stdout, "Hello, everyone!\n")
    ```
  
  - 变量重声明其实算是一个语法糖（或者叫便利措施）。它允许我们在使用短变量声明时不用理会被赋值的多个变量中是否包含旧变量。
  
- 一个程序实体被创造出来，是为了让别的代码引用的。那么，哪里的代码可以引用它呢，这就涉及了它的作用域。

  - 序实体的访问权限有三种：包级私有的、模块级私有的和公开的。这其实就是 Go 语言在语言层面，依据代码块对程序实体作用域进行的定义。
  - **一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制。**对“高内聚，低耦合”这种程序设计思想的实践，恰恰可以从这里开始。

- **如果一个变量与其外层代码块中的变量重名会出现什么状况**

  - ```go
    package main
     
    import "fmt"
    
    // 这个命令源码文件中有四个代码块，它们是：全域代码块、main包代表的代码块、main函数代表的代码块，以及在main函数中的一个用花括号包起来的代码块。
    
    var block = "package"
     
    // 在后三个代码块中分别声明了一个名为block的变量，并分别把字符串值"package"、"function"和"inner"赋给了它们。
    func main() {
    	block := "function"
    	{
    		block := "inner"
    		fmt.Printf("The block is %s.\n", block)
    	}
    	fmt.Printf("The block is %s.\n", block)
    }
    
    
    ---
    
    The block is inner.
    The block is function.
    
    ```

  - 查找过程

    - 首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。
    - 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找。
    - 一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了

  - 如果我们在当前源码文件中导入了其他代码包，那么引用其中的程序实体时，是需要以限定符为前缀的。所以程序在找代表变量未加限定符的名字（即标识符）的时候，是不会去被导入的代码包中查找的。

    - 但有个特殊情况，如果我们把代码包导入语句写成`import . XXX`的形式（注意中间的那个“.”），那么就会让这个“XXX”包中公开的程序实体，被当前源码文件中的代码，视为当前代码包中的程序实体。
    - 比如，如果有代码包导入语句`import . fmt`，那么我们在当前源码文件中引用`fmt.Printf`函数的时候直接用`Printf`就可以了。在这个特殊情况下，程序在查找当前源码文件后会先去查用这种方式导入的那些代码包。

- **不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿**

  > **把不同代码块中的重名变量叫做“可重名变量”**

  

  - 变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。
  - 变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。
  - 不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，它们的类型可以是任意的。
  - 如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。但是这种现象绝对不会在变量重声明的场景下出现。

- **怎样判断一个变量的类型**

  - 使用“类型断言”表达式

    - 类型断言表达式的语法形式是`x.(T)`。其中的`x`代表要被判断类型的值。这个值当下的类型必须是接口类型的，不过具体是哪个接口类型其实是无所谓的。

    - ```go
      
      /*
      
      它包括了用来把container变量的值转换为空接口值的interface{}(container)。以及一个用于判断前者的类型是否为切片类型 []string 的 .([]string)。
      
      这里的ok也可以没有。也就是说，类型断言表达式的结果，可以只被赋给一个变量，在这里是value。但是这样的话，当判断为否时就会引发异常。
      
      这种异常在 Go 语言中被叫做panic，我把它翻译为运行时恐慌。因为它是一种在 Go 程序运行期间才会被抛出的异常，而“恐慌”二字是英文 Panic 的中文直译。除非显式地“恢复”这种“恐慌”，否则它会使 Go 程序崩溃并停止。所以，在一般情况下，我们还是应该使用带ok变量的写法。
      
      */
      
      /*
      
      在 Go 语言中，interface{}代表空接口，任何类型都是它的实现类型。
      []string是一个类型字面量。所谓类型字面量，就是用来表示数据类型本身的若干个字符。
      比如，string是表示字符串类型的字面量，uint8是表示 8 位无符号整数类型的字面量。
      
      */
      
      value, ok := interface{}(container).([]string)
      ```

  - **请记住，一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）。**

    - 比如`struct{}`，它就代表了不包含任何字段和方法的、空的结构体类型。
    - 而空接口`interface{}`则代表了不包含任何方法定义的、空的接口类型。

- 类型转换

  - 对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。

    - 当整数值的类型的有效范围由宽变窄时，只需在补码形式下截掉一定数量的高位二进制数即可。
    - 比如，`int16`类型的值`-255`的补码是`1111111100000001`。如果我们把该值转换为`int8`类型的值，那么 Go 语言会把在较高位置（或者说最左边位置）上的 8 位二进制数直接截掉，从而得到`00000001`。
    - 正数的补码等于原码，负数的补码才是反码＋1

  - 虽然直接把一个整数值转换为一个`string`类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的 Unicode 代码点，否则转换的结果将会是`"�"`（仅由高亮的问号组成的字符串值）。

    - ```go
      // 由于-1肯定无法代表一个有效的 Unicode 代码点，所以得到的总会是"�"。在实际工作中，我们在排查问题时可能会遇到�，你需要知道这可能是由于什么引起的。
      
      string(-1)
      ```

  - `string`类型与各种切片类型之间的互转

    - 一个值在从`string`类型向`[]byte`类型转换时代表着以 UTF-8 编码的字符串会被拆分成零散、独立的字节。

    - 除了与 ASCII 编码兼容的那部分字符集，以 UTF-8 编码的某个单一字节是无法代表一个字符的。

      - ```go
        string([]byte{'\xe4', '\xbd', '\xa0', '\xe5', '\xa5', '\xbd'}) // 你好
        
        ```

#  数组和切片

- **数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。**

  - 数组的长度在声明它的时候就必须给定，而切片的类型字面量中只有元素的类型，而没有长度。切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减小。
  - **我们其实可以把切片看做是对数组的一层简单的封装**，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。
  - 也正因为如此，Go 语言的切片类型属于引用类型，同属引用类型的还有字典类型、通道类型、函数类型等；而 Go 语言的数组类型则属于值类型，同属值类型的有基础数据类型以及结构体类型。
    - 在 Go 语言中，我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了。

- 怎样正确估算切片的长度和容量

  - 我们通过调用内建函数`len`，得到数组和切片的长度。通过调用内建函数`cap`，我们可以得到它们的容量。

  - 但要注意，数组的容量永远等于其长度，都是不可变的。切片的容量却不是这样，并且它的变化是有规律可寻的。

  - ```go
    	// 示例 1。
      	s1 := make([]int, 5)
      	fmt.Printf("The length of s1: %d\n", len(s1))
      	fmt.Printf("The capacity of s1: %d\n", cap(s1))
      	fmt.Printf("The value of s1: %d\n", s1)
      	s2 := make([]int, 5, 8)
      	fmt.Printf("The length of s2: %d\n", len(s2))
      	fmt.Printf("The capacity of s2: %d\n", cap(s2))
      	fmt.Printf("The value of s2: %d\n", s2)
      
    // 切片s1和s2的容量分别是5和8
    // 当我们用make函数初始化切片时，如果不指明其容量，那么它就会和长度一致。如果在初始化时指明了容量，那么切片的实际容量也就是它了
    
    
    ---
    
    s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
    s4 := s3[3:6]
    fmt.Printf("The length of s4: %d\n", len(s4))
    fmt.Printf("The capacity of s4: %d\n", cap(s4))
    fmt.Printf("The value of s4: %d\n", s4)
    
    /*
    由于s4是通过在s3上施加切片操作得来的，所以s3的底层数组就是s4的底层数组。
    又因为，在底层数组不变的情况下，切片代表的窗口可以向右扩展，直至其底层数组的末尾。
    所以，s4的容量就是其底层数组的长度8, 减去上述切片表达式中的那个起始索引3，即5。
    
    注意，切片代表的窗口是无法向左扩展的。也就是说，我们永远无法透过`s4`看到`s3`中最左边的那 3 个元素。
    对于`s4`来说，切片表达式`s4[0:cap(s4)]`就可以做到。我想你应该能看懂。该表达式的结果值（即一个新的切片）会是`[]int{4, 5, 6, 7, 8}`，其长度和容量都是`5`。
    
    */
    ```

- 怎样估算切片容量的增长

  - 一旦一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。**在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的 2 倍。**
  - **但是，当原切片的长度（以下简称原长度）大于或等于`1024`时，Go 语言将会以原容量的`1.25`倍作为新容量的基准（以下新容量基准）。**新容量基准会被调整（不断地与`1.25`相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量往往会比新长度大一些，当然，相等也是可能的。
  - **另外，如果我们一次追加的元素过多，以至于使新长度比原容量的 2 倍还要大，那么新容量就会以新长度为基准。**注意，与前面那种情况一样，最终的新容量在很多时候都要比新容量基准更大一些。更多细节可参见`runtime`包中 slice.go 文件里的`growslice`及相关函数的具体实现。

- **切片的底层数组什么时候会被替换**

  - 确切地说，一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。
  - 请记住，在无需扩容时，`append`函数返回的是指向原底层数组的新切片，而在需要扩容时，`append`函数返回的是指向新底层数组的新切片。

- 只要新长度不会超过切片的原容量，那么使用`append`函数对其追加元素的时候就不会引起扩容。这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉。

- 创建 slice 的开销很小。不过执行 append 有可能（注意，不是每次）会造成内存的申请和元素值的拷贝。这属于不可忽视的开销。

  - 切片本身有着占用内存少和创建便捷等特点，但它的本质上还是数组。切片的一大好处是可以让我们通过窗口快速地定位并获取，或者修改底层数组中的元素。
  - 不过，当我们想删除切片中的元素的时候就没那么简单了。元素复制一般是免不了的，就算只删除一个元素，有时也会造成大量元素的移动。这时还要注意空出的元素槽位的“清空”，否则很可能会造成内存泄漏。
  - 对比来看，一个链表所占用的内存空间，往往要比包含相同元素的数组所占内存大得多。这是由于链表的元素并不是连续存储的，所以相邻的元素之间需要互相保存对方的指针。不但如此，每个元素还要存有它所属链表的指针。

- 如果有多个切片指向了同一个底层数组，那么你认为应该注意些什么？

  - 当两个长度不一的切片使用同一个底层数组，并且两切片的长度均小于数组的容量时，对其中长度较小的一个切片进行append操作，但不超过底层数组容量，这时会影响长度较长切片中原来比较小切片多看到的值，因为底层数组被修改了。

  - 底层数组的变动会影响多个切片





# container包中的那些容器

- Go 语言的链表实现在标准库的`container/list`代码包中。这个代码包中有两个公开的程序实体——`List`和`Element`，List 实现了一个双向链表（以下简称链表），而 Element 则代表了链表中元素的结构。

- 可以把自己生成的`Element`类型值传给链表吗

  - 不会接受，这些方法将不会对链表做出任何改动。因为我们自己生成的`Element`值并不在链表中，所以也就谈不上“在链表中移动元素”。更何况链表不允许我们把自己生成的`Element`值插入其中

  - 我们在这里用到了`List`的四种方法。

    - ```go
      /*
      `MoveBefore`方法和`MoveAfter`方法，它们分别用于把给定的元素移动到另一个元素的前面和后面。
      `MoveToFront`方法和`MoveToBack`方法，分别用于把给定的元素移动到链表的最前端和最后端。
      
      List的方法还有下面这几种：
      
      Front和Back方法分别用于获取链表中最前端和最后端的元素，
      InsertBefore和InsertAfter方法分别用于在指定的元素之前和之后插入新元素，PushFront和PushBack方法则分别用于在链表的最前端和最后端插入新元素。
      
      */
      func (l *List) MoveBefore(e, mark *Element)
      func (l *List) MoveAfter(e, mark *Element)
       
      func (l *List) MoveToFront(e *Element)
      func (l *List) MoveToBack(e *Element)
      
      ```

    - 在`List`包含的方法中，用于插入新元素的那些方法都只接受`interface{}`类型的值。这些方法在内部会使用`Element`值，包装接收到的新元素。

    - **这样做正是为了避免直接使用我们自己生成的元素**，主要原因是避免链表的内部关联，遭到外界破坏，这对于链表本身以及我们这些使用者来说都是有益的。

- 为什么链表可以做到开箱即用

  - `List`和`Element`都是结构体类型。结构体类型有一个特点，那就是它们的零值都会是拥有特定结构，但是没有任何定制化内容的值，相当于一个空壳。值中的字段也都会被分别赋予各自类型的零值。
    - 比如，经过语句`var a [2]int`声明的变量`a`的值，将会是一个包含了两个`0`的整数数组。又比如，经过语句`var s []int`声明的变量`s`的值将会是一个`[]int`类型的、值为`nil`的切片。
  - **Go 语言标准库中很多结构体类型的程序实体都做到了开箱即用。**这也是在编写可供别人使用的代码包（或者说程序库）时，我们推荐遵循的最佳实践之一
    - 所谓的**延迟初始化**，你可以理解为把初始化操作延后，仅在实际需要的时候才进行。延迟初始化的优点在于“延后”，它可以分散初始化操作带来的计算量和存储空间消耗。
      - 链表的`PushFront`方法、`PushBack`方法、`PushBackList`方法以及`PushFrontList`方法总会先判断链表的状态，并在必要时进行初始化，这就是延迟初始化。
      - 而且，我们在向一个空的链表中添加新元素的时候，肯定会调用这四个方法中的一个，这时新元素中指向所属链表的指针，一定会被设定为当前链表的指针。所以，指针相等是链表已经初始化的充分必要条件。
      - **`List`利用了自身以及`Element`在结构上的特点，巧妙地平衡了延迟初始化的优缺点**，使得链表可以开箱即用，并且在性能上可以达到最优。
    - 例如，如果我们需要集中声明非常多的大容量切片的话，那么那时的 CPU 和内存空间的使用量肯定都会一个激增，并且只有设法让其中的切片及其底层数组被回收，内存使用量才会有所降低。
    - **如果数组是可以被延迟初始化的，那么计算量和存储空间的压力就可以被分散到实际使用它们的时候。这些数组被实际使用的时间越分散，延迟初始化带来的优势就会越明显。**
    - 实际上，Go 语言的切片就起到了延迟初始化其底层数组的作用

- `Ring`与`List`的区别

  - `container/ring`包中的`Ring`类型实现的是一个循环链表，也就是我们俗称的环。其实`List`在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端。
    - 所以也可以说，`List`的零值是一个只包含了根元素，但不包含任何实际元素值的空链表。
  - `Ring`类型的数据结构仅由它自身即可代表，而`List`类型则需要由它以及`Element`类型联合表示。这是表示方式上的不同，也是结构复杂度上的不同。
  - 一个`Ring`类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个`List`类型的值则代表了一个完整的链表。这是表示维度上的不同。
  - 在创建并初始化一个`Ring`值的时候，我们可以指定它包含的元素的数量，但是对于一个`List`值来说却不能这样做（也没有必要这样做）。循环链表一旦被创建，其长度是不可变的。这是两个代码包中的`New`函数在功能上的不同，也是两个类型在初始化值方面的第一个不同。
  - 仅通过`var r ring.Ring`语句声明的`r`将会是一个长度为`1`的循环链表，而`List`类型的零值则是一个长度为`0`的链表。别忘了`List`中的根元素不会持有实际元素值，因此计算长度时不会包含它。这是两个类型在初始化值方面的第二个不同。
  - `Ring`值的`Len`方法的算法复杂度是 O(N) 的，而`List`值的`Len`方法的算法复杂度则是 O(1) 的。这是两者在性能方面最显而易见的差别。

  

  

  

  

# 字典的操作和约束

- 为什么字典的键类型会受到约束
  - Go 语言的字典类型其实是一个哈希表（hash table）的特定实现，在这个实现中，键和元素的最大不同在于，键的类型是受限的，而元素却可以是任意类型的。
  - 如果要探究限制的原因，我们就先要了解哈希表中最重要的一个过程：映射。
  - **Go 语言字典的键类型不可以是函数类型、字典类型和切片类型。**
    - Go 语言规范规定，在键类型的值之间必须可以施加操作符`==`和`!=`。换句话说，键类型的值必须要支持判等操作。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。
- 应该优先考虑哪些类型作为字典的键类型
  - **求哈希和判等操作的速度越快，对应的类型就越适合作为键类型**
  - 以求哈希的操作为例，宽度越小的类型速度通常越快。对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。对于字符串类型，由于它的宽度是不定的，所以要看它的值的具体长度，长度越短求哈希越快。
    - 类型的宽度是指它的单个值需要占用的字节数。比如，`bool`、`int8`和`uint8`类型的一个值需要占用的字节数都是`1`，因此这些类型的宽度就都是`1`。
  - 再来看高级类型。对数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并，所以速度就取决于它的元素类型以及它的长度。细则同上。
  - 与之类似，对结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并，所以关键在于它的各个字段的类型以及字段的数量。而对于接口类型，具体的哈希算法，则由值的实际类型决定
    - 我不建议你使用这些高级数据类型作为字典的键类型，不仅仅是因为对它们的值求哈希，以及判等的速度较慢，更是因为在它们的值中存在变数。
- 在值为`nil`的字典上执行读操作会成功吗，那写操作呢
  - 除了添加键 - 元素对，我们在一个值为`nil`的字典上做任何操作都不会引起错误。当我们试图在一个值为`nil`的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。





# 函数

- 函数是一等的公民

  - 简单来说，这意味着函数不但可以用于封装代码、分割功能、解耦逻辑，还可以化身为普通的值，在其他函数间传递、赋予变量、做类型判断和转换等等，就像切片和字典的值那样

  - 而更深层次的含义就是：函数值可以由此成为能够被随意传播的独立逻辑组件（或者说功能模块）。

  - ```go
    package main
     
    import "fmt"
     
    type Printer func(contents string) (n int, err error)
     
    func printToStd(contents string) (bytesNum int, err error) {
    	return fmt.Println(contents)
    }
     
    func main() {
    	var p Printer
    	p = printToStd
    	p("something")
    }
    ```

- 怎样编写高阶函数

  - 高阶函数可以满足下面的两个条件
    - 接受其他的函数作为参数传入
    - 把其他的函数作为结果返回
  - 只要满足了其中任意一个特点，我们就可以说这个函数是一个高阶函数

- 通过编写`calculate`函数来实现两个整数间的加减乘除运算，但是希望两个整数和具体的操作都由该函数的调用方给出

  - ```go
    import (
    	"errors"
    	"fmt"
    )
    
    type operate func(x, y int) int
    
    // 方案1。
    func calculate(x int, y int, op operate) (int, error) {
    	if op == nil {
    		return 0, errors.New("invalid operation")
    	}
    	return op(x, y), nil
    }
    
    // 方案2。
    type calculateFunc func(x int, y int) (int, error)
    
    // genCalculator函数内部，实际上就实现了一个闭包，而genCalculator函数也是一个高阶函数。
    // genCalculator函数只做了一件事，那就是定义一个匿名的、calculateFunc类型的函数并把它作为结果值返回。
    // 它里面使用的变量op既不代表它的任何参数或结果也不是它自己声明的，而是定义它的genCalculator函数的参数，所以是一个自由变量。
    func genCalculator(op operate) calculateFunc {
    	return func(x int, y int) (int, error) {
        // 会发现op代表的是genCalculator函数的参数，然后，它会把这两者联系起来。这时可以说，自由变量op被“捕获”了。
        // 当程序运行到这里的时候，op就是那个参数值了。如此一来，这个闭包函数的状态就由“不确定”变为了“确定”，或者说转到了“闭合”状态，至此也就真正地形成了一个闭包。
    		if op == nil {
    			return 0, errors.New("invalid operation")
    		}
    		return op(x, y), nil
    	}
    }
    
    func main() {
    	// 方案1。
    	x, y := 12, 23
    	op := func(x, y int) int {
    		return x + y
    	}
    	result, err := calculate(x, y, op)
    	fmt.Printf("The result: %d (error: %v)\n",
    		result, err)
    	result, err = calculate(x, y, nil)
    	fmt.Printf("The result: %d (error: %v)\n",
    		result, err)
    
    	// 方案2。
    	x, y = 56, 78
    	add := genCalculator(op)
    	result, err = add(x, y)
    	fmt.Printf("The result: %d (error: %v)\n",
    		result, err)
    }
    ```

- 闭包的意义

  - 表面上看，我们只是延迟实现了一部分程序逻辑或功能而已，但实际上，我们是在动态地生成那部分程序逻辑。
  - 我们可以借此在程序运行的过程中，根据需要生成功能不同的函数，继而影响后续的程序行为。这与 GoF 设计模式中的“模板方法”模式有着异曲同工之妙

- 传入函数的那些参数值后来怎么样了

  - 所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，而是它的副本。

  - 注意，对于引用类型，比如：切片、字典、通道，像上面那样复制它们的值，只会拷贝它们本身而已，并不会拷贝它们引用的底层数据。也就是说，这时只是浅表复制，而不是深层复制。

    - 以切片值为例，如此复制的时候，只是拷贝了它指向底层数组中某一个元素的指针，以及它的长度值和容量值，而它的底层数组并不会被拷贝。

  - 另外还要注意，就算我们传入函数的是一个值类型的参数值，但如果这个参数值中的某个元素是引用类型的，那么我们仍然要小心。

    - ```go
      // 变量complexArray1是[3][]string类型的，也就是说，虽然它是一个数组，但是其中的每个元素又都是一个切片。
      
      complexArray1 := [3][]string{
      	[]string{"d", "e", "f"},
      	[]string{"g", "h", "i"},
      	[]string{"j", "k", "l"},
      }
      ```

    - `complexArray1`被传入函数的话，这个函数中对该参数值的修改会影响到它的原值吗

      - 分2种情况，若是修改数组中的切片的某个元素，会影响原数组。若是修改数组的某个元素即a[1]=[]string{"x"}就不会影响原数组。
      - 谨记Go中都是浅拷贝，值类型和引用类型的区别

- 函数真正拿到的参数值其实只是它们的副本，那么函数返回给调用方的结果值也会被复制吗

  - 当函数返回指针类型时不会发生拷贝。当函数返回非指针类型并把结果赋值给其它变量肯定会发生拷贝





# 结构体及其方法

- 如果结构体类型的某个字段声明中只有一个类型名，那么该字段代表了什么

  - ```go
    type Animal struct {
    	scientificName string // 学名。
    	AnimalCategory    // 动物基本分类。
    }
    ```

  - 字段声明`AnimalCategory`代表了`Animal`类型的一个嵌入字段。Go 语言规范规定，如果一个字段的声明中只有字段的类型名而没有字段的名称，那么它就是一个嵌入字段，也可以被称为匿名字段。我们可以通过此类型变量的名称后跟“.”，再后跟嵌入字段类型的方式引用到该字段。也就是说，嵌入字段的类型既是类型也是名称。

- 那如果我也为`Animal`类型编写一个`String`方法呢？这里会调用哪一个呢

  - 答案是，`animal`的`String`方法会被调用。这时，我们说，嵌入字段`AnimalCategory`的`String`方法被“屏蔽”了。注意，只要名称相同，无论这两个方法的签名是否一致，被嵌入类型的方法都会“屏蔽”掉嵌入字段的同名方法。

  - 不过，即使被屏蔽了，我们仍然可以通过链式的选择表达式，选择到嵌入字段的字段或方法，就像我在`Category`方法中所做的那样。这种“屏蔽”其实还带来了一些好处。我们看看下面这个`Animal`类型的`String`方法的实现：

    - ```go
      func (a Animal) String() string {
      	return fmt.Sprintf("%s (category: %s)",
      		a.scientificName, a.AnimalCategory)
      }
      ```

- Go 语言是用嵌入字段实现了继承吗

  - Go 语言中根本没有继承的概念，它所做的是通过嵌入字段的方式实现了类型之间的**组合**		
  - 简单来说，面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过**侵入**的方式来实现的。
  - 类型之间的组合采用的是**非声明**的方式，我们不需要显式地声明某个类型实现了某个接口，或者一个类型继承了另一个类型。
  - 同时，类型组合也是**非侵入式**的，它不会破坏类型的封装或加重类型之间的耦合。
  - 我们要做的只是把类型当做字段嵌入进来，然后坐享其成地使用嵌入字段所拥有的一切。如果嵌入字段有哪里不合心意，我们还可以用“包装”或“屏蔽”的方式去调整和优化。
  - 另外，类型间的组合也是灵活的，我们总是可以通过嵌入字段的方式把一个类型的属性和能力“嫁接”给另一个类型。
  - 这时候，**被嵌入类型也就自然而然地实现了嵌入字段所实现的接口。**再者，组合要比继承**更加简洁和清晰**，Go 语言可以轻而易举地通过嵌入多个字段来实现功能强大的类型，却不会有多重继承那样复杂的层次结构和可观的管理成本。

- **值方法和指针方法**

  - 方法的接收者类型必须是某个自定义的数据类型，而且不能是接口类型或接口的指针类型。**所谓的值方法，就是接收者类型是非指针的自定义数据类型的方法。**

  - **值方法的接收者**是该方法所属的那个类型值的一个**副本**。我们在该方法内对该**副本的修改一般都不会体现在原值上**，除非这个类型本身是某个引用类型（比如切片或字典）的别名类型。

    - 而**指针方法的接收者**，是该方法所属的那个基本类型值的指针值的一个副本。我们在这样的方法内**对该副本指向的值进行修改，却一定会体现在原值上**。

    - ```go
      func (cat *Cat) SetName(name string) {
      	cat.name = name
      }
      ```

  - **一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。**

    - 严格来讲，我们在这样的基本类型的值上只能调用到它的值方法。但是，Go 语言会适时地为我们进行自动地转译，使得我们在这样的值上也能调用到它的指针方法
    - 比如，在`Cat`类型的变量`cat`之上，之所以我们可以通过`cat.SetName("monster")`修改猫的名字，是因为 Go 语言把它自动转译为了`(&cat).SetName("monster")`，即：先取`cat`的指针值，然后在该指针值上调用`SetName`方法。

- 我们可以在结构体类型中嵌入某个类型的指针类型吗？如果可以，有哪些注意事项？

  - 我们可以在结构体中嵌入某个类型的指针类型， 它和普通指针类似，默认初始化为nil,因此在用之前需要人为初始化，否则可能引起错误

- 字面量`struct{}`代表了什么？又有什么用处？

  - 空结构体不占用内存空间，但是具有结构体的一切属性，如可以拥有方法，可以写入channel。所以当我们需要使用结构体而又不需要具体属性时可以使用它。



# 接口类型

- 对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征（即全部的方法），那么它就一定是这个接口的实现类型。这是一种无侵入式的接口实现方式。

- 当我们为一个接口变量赋值时会发生什么

  - ```go
    type Pet interface {
    	SetName(name string)
    	Name() string
    	Category() string
    }
    
    ---
    
    // pet变量的字段name的值依然是"little pig"
    dog := Dog{"little pig"}
    var pet Pet = dog
    dog.SetName("monster")
    
    
    // 这时的dog2的name仍然会是"little pig"。
    dog1 := Dog{"little pig"}
    dog2 := dog1
    dog1.name = "monster"
    
    
    ---
    // 运行后发现输出不仅d的name字段变为了“big dog”，同样pet接口变量也变成了“big dog”。
    // 传递给pet变量的同样是&d的一个指针副本，因为传递的是副本，所以无论是指针还是值，都可以说是浅复制；且由于传递的是指针（虽然是副本），但还是会对指向的底层变量做修改。
    d := Dog{name: "little dog"}
    var pet Pet = &d
    d.SetName("big dog")
    
    
    
    ```

  - 对于一个接口类型的变量来说，例如上面的变量`pet`，我们赋给它的值可以被叫做它的实际值（也称**动态值**），而该值的类型可以被叫做这个变量的实际类型（也称**动态类型**）。

  - 首先，由于`dog`的`SetName`方法是指针方法，所以该方法持有的接收者就是指向`dog`的指针值的副本，因而其中对接收者的`name`字段的设置就是对变量`dog`的改动。那么当`dog.SetName("monster")`执行之后，`dog`的`name`字段的值就一定是`"monster"`。

  - 为什么`dog`的`name`字段值变了，而`pet`的却没有呢？这里有一条通用的规则需要你知晓：如果我们使用一个变量给另外一个变量赋值，那么真正赋给后者的，并不是前者持有的那个值，而是该值的一个**副本**

- 接口类型值的存储方式和结构

  - 接口类型本身是无法被值化的。在我们赋予它实际的值之前，它的值一定会是`nil`，这也是它的零值。
  - 一旦它被赋予了某个实现类型的值，它的值就不再是`nil`了。不过要注意，即使我们像前面那样把`dog`的值赋给了`pet`，`pet`的值与`dog`的值也是不同的。这不仅仅是副本与原值的那种不同。
    - 这样一个变量的值其实是这个专用数据结构（iface）的一个实例，而不是我们赋给该变量的那个实际的值。所以我才说，`pet`的值与`dog`的值肯定是不同的，无论是从它们存储的内容，还是存储的结构上来看都是如此。不过，我们可以认为，这时`pet`的值中包含了`dog`值的副本。
    - **总之，接口变量被赋予动态值的时候，存储的是包含了这个动态值的副本的一个结构更加复杂的值。**
    - 如果我们把一个值为nil的某个实现类型的变量赋给了接口变量，在这个接口变量上仍然可以访问其方法，但无法访问其属性。使用时需要注意：如果涉及到变量属性，这些属性值均为默认值。

- 接口变量的值在什么情况下才真正为`nil`

  - ```go
    var dog1 *Dog
    fmt.Println("The first dog is nil. [wrap1]")
    dog2 := dog1
    fmt.Println("The second dog is nil. [wrap1]")
    var pet Pet = dog2
    if pet == nil {
    	fmt.Println("The pet is nil. [wrap1]")
    } else {
    	fmt.Println("The pet is not nil. [wrap1]")
    }
    ```

  - 当我们把`dog2`的值赋给变量`pet`的时候，`dog2`的值会先被复制，不过由于在这里它的值是`nil`，所以就没必要复制了。

    - 然后，Go 语言会用我上面提到的那个专用数据结构`iface`的实例包装这个`dog2`的值的副本，这里是`nil`。
    - 虽然被包装的动态值是`nil`，但是`pet`的值却不会是`nil`，因为这个动态值只是`pet`值的一部分而已。这时的`pet`的动态类型就存在了，是`*Dog`。
    - 在 Go 语言中，我们把由字面量`nil`表示的值叫做无类型的`nil`。这是真正的`nil`，因为它的类型也是`nil`的。虽然`dog2`的值是真正的`nil`，**但是当我们把这个变量赋给`pet`的时候，Go 语言会把它的类型和值放在一起考虑**。

- 怎样实现接口之间的组合

  - 接口类型间的嵌入也被称为接口的组合。

  - 接口类型间的嵌入要更简单一些，因为它不会涉及方法间的“屏蔽”。只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名彼此不同也会是如此。

  - Go 语言团队鼓励我们声明体量较小的接口，并建议我们通过这种接口间的组合来扩展程序、增加程序的灵活性。

    - 这是因为相比于包含很多方法的大接口而言，小接口可以更加专注地表达某一种能力或某一类特征，同时也更容易被组合在一起

    - Go 语言标准库代码包`io`中的`ReadWriteCloser`接口和`ReadWriter`接口就是这样的例子，它们都是由若干个小接口组合而成的。以`io.ReadWriteCloser`接口为例，它是由`io.Reader`、`io.Writer`和`io.Closer`这三个接口组成的。

    - ```go
      type Animal interface {
      	ScientificName() string
      	Category() string
      }
       
      type Pet interface {
      	Animal
      	Name() string
      }
      ```



# 指针

-  Go 语言中的哪些值是不可寻址的

  - 常量的值总是会被存储到一个确切的内存区域中，并且这种值肯定是**不可变的**。基本类型值的字面量也是一样，其实它们本就可以被视为常量
    - 第一个关键词：不可变的。由于 Go 语言中的字符串值也是不可变的，所以对于一个字符串类型的变量来说，基于它的索引或切片的结果值也都是不可寻址的
    - 再来看函数。函数在 Go 语言中是一等公民，所以我们可以把代表函数或方法的字面量或标识符赋给某个变量、传给某个函数或者从某个函数传出。但是，这样的函数和方法都是不可寻址的。一个原因是函数就是代码，是不可变的。
      - 另一个原因是，拿到指向一段代码的指针是不安全的。此外，对函数或方法的调用结果值也是不可寻址的，这是因为它们都属于临时结果。
  - 算术操作的结果值属于一种**临时结果**。在我们把这种结果值赋给任何变量或常量之前，即使能拿到它的内存地址也是没有任何意义的。
    - 第二个关键词：临时结果。这个关键词能被用来解释很多现象。我们可以把各种对值字面量施加的表达式的求值结果都看做是临时结果。
    - 比如，对数组字面量和字典字面量的**索引**结果值，又比如，对数组字面量和切片字面量的**切片**结果值。它们都属于临时结果，都是不可寻址的。
      - 对切片字面量的切片结果值为什么却是不可寻址的？这是因为切片表达式总会返回一个新的切片值，而这个新的切片值在被赋给变量之前属于临时结果。
    - 一个需要特别注意的例外是，**对切片字面量的索引结果值是可寻址的**。因为不论怎样，每个切片值都会持有一个底层数组，而这个底层数组中的每个元素值都是有一个确切的内存地址的。
  - 再说一个例外。**我们通过对字典类型的变量施加索引表达式，得到的结果值不属于临时结果，可是，这样的值却是不可寻址的**。原因是，字典中的每个键 - 元素对的存储位置都可能会变化，而且这种变化外界是无法感知的。
    - 我们都知道，字典中总会有若干个哈希桶用于均匀地储存键 - 元素对。当满足一定条件时，字典可能会改变哈希桶的数量，并适时地把其中的键 - 元素对搬运到对应的新的哈希桶中。
    - 在这种情况下，获取字典中任何元素值的指针都是无意义的，也是**不安全的**。
    - 第三个关键词：**不安全的。“不安全的”操作很可能会破坏程序的一致性，**引发不可预知的错误，从而严重影响程序的功能和稳定性。
  - 总结
    - **不可变的**值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。
    - 绝大多数被视为**临时结果**的值都是不可寻址的。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。
    - 若拿到某值的指针可能会破坏程序的一致性，那么就是**不安全的**，该值就不可寻址。由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。
    - 如果我们把临时结果赋给一个变量，那么它就是可寻址的了。如此一来，取得的指针指向的就是这个变量持有的那个值了。

- 不可寻址的值在使用上有哪些限制

  - 无法使用取址操作符`&`获取它们的指针

    - ```go
      func New(name string) Dog {
      	return Dog{name}
      }
      
      New("little pig").SetName("monster")
      ```

    - 我们可以在一个基本类型的值上调用它的指针方法，这是因为 Go 语言会自动地帮我们转译。

      - 更具体地说，对于一个`Dog`类型的变量`dog`来说，调用表达式`dog.SetName("monster")`会被自动地转译为`(&dog).SetName("monster")`，即：先取`dog`的指针值，再在该指针值上调用`SetName`方法。
      - 由于`New`函数的调用结果值是不可寻址的，所以无法对它进行取址操作。因此，上边这行链式调用会让编译器报告两个错误，一个是果，即：不能在`New("little pig")`的结果值上调用指针方法。一个是因，即：不能取得`New("little pig")`的地址。

  - 只要在**`++`或`--`**的左边添加一个表达式，就可以组成一个自增语句或自减语句，但是，它还明确了一个很重要的限制，那就是**这个表达式的结果值必须是可寻址的**。这就使得针对值字面量的表达式几乎都无法被用在这里。

    - 不过这有一个例外，**虽然对字典字面量和字典变量索引表达式的结果值都是不可寻址的，但是这样的表达式却可以被用在自增语句和自减语句中。**

  - 与之类似的规则还有两个。**一个是，在赋值语句中，赋值操作符左边的表达式的结果值必须可寻址的，但是对字典的索引结果值也是可以的。**

  - 另一个是，在带有`range`子句的`for`语句中，在`range`关键字左边的表达式的结果值也都必须是可寻址的，不过对字典的索引结果值同样可以被用在这里。以上这三条规则我们合并起来记忆就可以了。





# go语句及其执行规则

- 不要通过共享数据来通讯，恰恰相反，要以通讯的方式共享数据。

  - 通道（也就是 channel）类型的值，可以被用来以通讯的方式共享数据。更具体地说，它一般被用来在不同的 goroutine 之间传递数据。那么 goroutine 到底代表着什么呢？
  - **简单来说，goroutine 代表着并发编程模型中的用户级线程**
    - 在 Go 程序当中，**Go 语言的运行时（runtime）系统会帮助我们自动地创建和销毁系统级的线程。**
    - 而**对应的用户级线程指的是架设在系统级线程之上的，由用户（或者说我们编写的程序）完全控制的代码执行流程**。用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理。
    - 这带来了很多**优势**，比如，因为它们的创建和销毁并不用通过操作系统去做，所以**速度会很快**，又比如，由于不用等着操作系统去调度它们的运行，所以往往会很容易控制并且可以很**灵活**。
    - 但是，劣势也是有的，**最明显也最重要的一个劣势就是复杂**。如果我们只使用了系统级线程，那么我们只要指明需要新线程执行的代码片段，并且下达创建或销毁线程的指令就好了，其他的一切具体实现都会由操作系统代劳。
    - 但是，如果使用用户级线程，我们就不得不既是指令下达者，又是指令执行者。我们必须全权负责与用户级线程有关的所有具体实现。

- **Go 语言不但有着独特的并发编程模型，以及用户级线程 goroutine，还拥有强大的用于调度 goroutine、对接系统级线程的调度器。**

  - 这个调度器是 Go 语言运行时系统的重要组成部分，它主要负责统筹调配 Go 并发编程模型中的三个主要元素，即：G（goroutine 的缩写）、P（processor 的缩写）和 M（machine 的缩写）。
  - 其中的 M 指代的就是系统级线程。而 P 指的是一种可以承载若干个 G，且能够使这些 G 适时地与 M 进行对接，并得到真正运行的中介。

- 什么是主 goroutine，它与我们启用的其他 goroutine 有什么不同

  - ```go
    // 这个命令源码文件被执行后会打印出什么内容
    // 绝大多数情况都会是“不会有任何内容被打印出来”。
    func main() {
    	for i := 0; i < 10; i++ {
    		go func() {
    			fmt.Println(i)
    		}()
    	}
    }
    ```

  - 与一个进程总会有一个主线程类似，每一个独立的 Go 程序在运行时也总会有一个主 goroutine。**这个主 goroutine 会在 Go 程序的运行准备工作完成后被自动地启用，并不需要我们做任何手动的操作**。

    - **每条`go`语句一般都会携带一个函数调用，这个被调用的函数常常被称为`go`函数。而主 goroutine 的`go`函数就是那个作为程序入口的`main`函数**
    - **一定要注意，`go`函数真正被执行的时间，总会与其所属的`go`语句被执行的时间不同。**当程序执行到一条`go`语句的时候，Go 语言的运行时系统，**会先试图从某个存放空闲的 G 的队列中获取一个 G（也就是 goroutine）**，它只有在找不到空闲 G 的情况下才会去创建一个新的 G。
    - 这也是为什么我总会说“启用”一个 goroutine，而不说“创建”一个 goroutine 的原因。已存在的 goroutine 总是会被优先复用。然而，创建 G 的成本也是非常低的。
    - 在拿到了一个空闲的 G 之后，Go 语言运行时系统会用这个 G 去**包装**当前的那个`go`函数（或者说该函数中的那些代码），然后再把这个 G 追加到某个存放可运行的 G 的**队列**中。
      - 这类队列中的 G 总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行。
      - 因此**，`go`函数的执行时间总是会明显滞后于它所属的`go`语句的执行时间**。当然了，这里所说的“明显滞后”是对于计算机的 CPU 时钟和 Go 程序来说的。我们在大多数时候都不会有明显的感觉。

  - **请记住，只要`go`语句本身执行完毕，Go 程序完全不会等待`go`函数的执行，它会立刻去执行后边的语句。这就是所谓的异步并发地执行。**

    - 这里“后边的语句”指的一般是`for`语句中的下一个迭代。
    - 请注意，`go`函数中的那个对`fmt.Println`函数的调用是以`for`语句中的变量`i`作为参数的。你可以想象一下，如果当`for`语句执行完毕的时候，这些`go`函数都还没有执行，那么它们引用的变量`i`的值将会是什么
      - 主 goroutine 有关的重要特性，即：**一旦主 goroutine 中的代码（也就是`main`函数中的那些代码）执行完毕，当前的 Go 程序就会结束运行**。
      - **如此一来，如果在 Go 程序结束的那一刻，还有 goroutine 未得到运行机会，那么它们就真的没有运行机会了，它们中的代码也就不会被执行了。**

- 在go语句执行后，Go运行时系统会把对应的go函数装进新启用的goroutine中，随后调度执行。因为这个调度是不保证先后顺序的，所以这些go函数的执行在默认情况下也是乱序的。

- 怎样才能让主 goroutine 等待其他 goroutine

  - 最简单粗暴的办法就是让主 goroutine“小睡”一会儿。

    - ```go
      for i := 0; i < 10; i++ {
      	go func() {
      		fmt.Println(i)
      	}()
      }
      time.Sleep(time.Millisecond * 500)
      ```

  - 你可能会想到，既然不容易预估时间，那我们就让其他的 goroutine 在运行完毕的时候告诉我们好了。

    - ```go
      func main() {
      	num := 10
        // 在声明通道sign的时候是以chan struct{}作为其类型的。其中的类型字面量struct{}有些类似于空接口类型interface{}，它代表了既不包含任何字段也不拥有任何方法的空结构体类型。
      	sign := make(chan struct{}, num)
      
      	for i := 0; i < num; i++ {
      		go func() {
      			fmt.Println(i)
            // 注意，struct{}类型值的表示法只有一个，即：struct{}{}。
            // 当我们仅仅把通道当作传递某种简单信号的介质的时候，用struct{}作为其元素类型是再好不过的了。
      			sign <- struct{}{}
      		}()
      	}
      
      	// 办法1。
      	//time.Sleep(time.Millisecond * 500)
      
      	// 办法2。
      	for j := 0; j < num; j++ {
      		<-sign
      	}
      }
      ```

  - 如果你知道标准库中的代码包`sync`的话，那么可能会想到`sync.WaitGroup`类型。

- 怎样让我们启用的多个 goroutine 按照既定的顺序运行

  - 在`go`语句被执行时，我们传给`go`函数的参数`i`会先被求值，如此就得到了当次迭代的序号。之后，无论`go`函数会在什么时候执行，这个参数值都不会变。也就是说，`go`函数中调用的`fmt.Println`函数打印的一定会是那个当次迭代的序号。

  - ```go
    func main() {
    	var count uint32
      /*
      
      trigger函数会不断地获取一个名叫count的变量的值，并判断该值是否与参数i的值相同。如果相同，那么就立即调用fn代表的函数，然后把count变量的值加1，最后显式地退出当前的循环。否则，我们就先让当前的 goroutine“睡眠”一个纳秒再进入下一个迭代。
    
    注意，我操作变量count的时候使用的都是原子操作。这是由于trigger函数会被多个 goroutine 并发地调用，所以它用到的非本地变量count，就被多个用户级线程共用了。因此，对它的操作就产生了竞态条件（race condition），破坏了程序的并发安全性。
    
    所以，我们总是应该对这样的操作加以保护，在sync/atomic包中声明了很多用于原子操作的函数。
    
    另外，由于我选用的原子操作函数对被操作的数值的类型有约束，所以我才对count以及相关的变量和参数的类型进行了统一的变更（由int变为了uint32）。
    
      */
    	trigger := func(i uint32, fn func()) {
    		for {
    			if n := atomic.LoadUint32(&count); n == i {
    				fn()
    				atomic.AddUint32(&count, 1)
    				break
    			}
    			time.Sleep(time.Nanosecond)
    		}
    	}
    	for i := uint32(0); i < 10; i++ {
    		go func(i uint32) {
    			fn := func() {
    				fmt.Println(i)
    			}
    			trigger(i, fn)
    		}(i)
    	}
      /*
      
      如果依然想让主 goroutine 最后一个运行完毕，所以还需要加一行代码。不过既然有了trigger函数，我就没有再使用通道。
      调用trigger函数完全可以达到相同的效果。由于当所有我手动启用的 goroutine 都运行完毕之后，count的值一定会是10，所以我就把10作为了第一个参数值。又由于我并不想打印这个10，所以我把一个什么都不做的函数作为了第二个参数值。
      */
    	trigger(10, func() {})
    }
    ```

  - 纵观`count`变量、`trigger`函数以及改造后的`for`语句和`go`函数，我要做的是，**让`count`变量成为一个信号，它的值总是下一个可以调用打印函数的`go`函数的序号。**

  - **这个序号其实就是启用 goroutine 时，那个当次迭代的序号。也正因为如此，`go`函数实际的执行顺序才会与`go`语句的执行顺序完全一致。**此外，这里的`trigger`函数实现了一种自旋（spinning）。除非发现条件已满足，否则它会不断地进行检查。





# 错误处理

- 对于具体错误的判断，Go 语言中都有哪些惯用法

  - 这个问题还可以换一种问法，即：怎样判断一个错误值具体代表的是哪一类错误？

  - 对于类型在已知范围内的一系列错误值，一般使用类型断言表达式或类型`switch`语句来判断；

    - 就拿`os`包中的几个代表错误的类型`os.PathError`、`os.LinkError`、`os.SyscallError`和`os/exec.Error`来说，它们的指针类型都是`error`接口的实现类型，同时它们也都包含了一个名叫`Err`，类型为`error`接口类型的代表潜在错误的字段。

    - ```go
      func underlyingError(err error) error {
      	switch err := err.(type) {
      	case *os.PathError:
      		return err.Err
      	case *os.LinkError:
      		return err.Err
      	case *os.SyscallError:
      		return err.Err
      	case *exec.Error:
      		return err.Err
      	}
      	return err
      }
      ```

    - 我们还拿`os`包来说，其中不少的错误值都是通过调用`errors.New`函数来初始化的，比如：`os.ErrClosed`、`os.ErrInvalid`以及`os.ErrPermission`，等等。

    - 如果我们在操作文件系统的时候得到了一个错误值，并且知道该值的潜在错误值肯定是上述值中的某一个，那么就可以用普通的`switch`语句去做判断，当然了，用`if`语句和判等操作符也是可以的。

    - ```go
      printError := func(i int, err error) {
      	if err == nil {
      		fmt.Println("nil error")
      		return
      	}
      	err = underlyingError(err)
      	switch err {
      	case os.ErrClosed:
      		fmt.Printf("error(closed)[%d]: %s\n", i, err)
      	case os.ErrInvalid:
      		fmt.Printf("error(invalid)[%d]: %s\n", i, err)
      	case os.ErrPermission:
      		fmt.Printf("error(permission)[%d]: %s\n", i, err)
      	}
      }
      ```

    - 虽然我不知道这些错误值的类型的范围，但却知道它们或它们的潜在错误值一定是某个已经在`os`包中定义的值。

    - **所以，我先用`underlyingError`函数得到它们的潜在错误值**，当然也可能只得到原错误值而已。然后，我用`switch`语句**对错误值进行判等操作，三个`case`子句分别对应我刚刚提到的那三个已存在于`os`包中的错误值。**如此一来，我就能分辨出**具体错误**了。

  - 对于已有相应变量且类型相同的一系列错误值，一般直接使用判等操作来判断；

  - 对于没有相应变量且类型未知的一系列错误值，只能使用其错误信息的字符串表示形式来做判断。

  - 好在我们总是能通过错误值的`Error`方法，拿到它的错误信息。其实`os`包中就有做这种判断的函数，比如：`os.IsExist`、`os.IsNotExist`和`os.IsPermission`。

- 怎样根据实际情况给予恰当的错误值

  - 构建错误值体系的基本方式有两种，即：**创建立体的错误类型体系和创建扁平的错误值列表。**
    - 由于在 Go 语言中实现接口是非侵入式的，所以我们可以做得很灵活。比如，在标准库的`net`代码包中，有一个名为`Error`的接口类型。它算是内建接口类型`error`的一个扩展接口，因为`error`是`net.Error`的嵌入接口。
    - 用类型建立起树形结构的错误体系，用统一字段建立起可追根溯源的链式错误关联。这是 Go 语言标准库给予我们的优秀范本，非常有借鉴意义。
    - `net`包中有很多错误类型都实现了`net.Error`接口，比如：
      1. `*net.OpError`；
      2. `*net.AddrError`；
      3. `net.UnknownNetworkError`等等。
    - 你可以把这些错误类型想象成一棵**树**，内建接口`error`就是树的根，而`net.Error`接口就是一个在根上延伸的第一级非叶子节点。
    - 同时，你也可以把这看做是一种**多层分类**的手段。当`net`包的使用者拿到一个错误值的时候，可以先判断它是否是`net.Error`类型的，也就是说该值是否代表了一个网络相关的错误。
    - 如果是，那么我们还可以再**进一步判断它的类型是哪一个更具体的错误类型**，这样就能知道这个网络相关的错误具体是由于操作不当引起的，还是因为网络地址问题引起的，又或是由于网络协议不正确引起的。
    - 不过要注意，**如果你不想让包外代码改动你返回的错误值的话，一定要小写其中字段的名称首字母**。你可以通过暴露某些方法让包外代码有进一步获取错误信息的权限，比如**编写一个可以返回包级私有的`err`字段值的公开方法`Err`**。
    - **之所以说错误类型体系是立体的，是因为从整体上看它往往呈现出树形的结构。**通过接口间的嵌套以及接口的实现，我们就可以构建出一棵错误类型树。
      - 通过这棵树，使用者就可以一步步地确定错误值的种类了。另外，为了追根溯源的需要，我们还可以在错误类型中，统一安放一个可以代表潜在错误的字段。这叫做链式的错误关联，可以帮助使用者找到错误的根源。
  - 相比于立体的错误类型体系，**扁平的错误值列表**就要简单得多了，**它其实就是若干个名称不同但类型相同的错误值集合。**当我们只是想预先创建一些代表已知错误的错误值时候，用这种扁平化的方式就很恰当了。
    - 不过，由于`error`是接口类型，所以**通过`errors.New`函数生成的错误值只能被赋给变量**，而不能赋给常量，又由于这些代表错误的变量需要给包外代码使用，所以其**访问权限只能是公开的**。
    - 这就带来了一个问题，如果有恶意代码改变了这些公开变量的值，那么程序的功能就必然会受到影响。
      - 这里有两个解决方案。**第一个方案是，先私有化此类变量**，也就是说，让它们的名称首字母变成小写，**然后编写公开的用于获取错误值以及用于判等错误值的函数。**
      - 比如，对于错误值`os.ErrClosed`，先改写它的名称，让其变成`os.errClosed`，然后再编写`ErrClosed`函数和`IsErrClosed`函数。
    - 再来说**第二个方案**，此方案存在于`syscall`包中。该包中有一个类型叫做`Errno`，该类型代表了系统调用时可能发生的底层错误。这个错误类型是`error`接口的实现类型，同时也是对内建类型`uintptr`的再定义类型。
    - 由于`uintptr`可以作为常量的类型，所以`syscall.Errno`自然也可以。**`syscall`包中声明有大量的`Errno`类型的常量，每个常量都对应一种系统调用错误。`syscall`包外的代码可以拿到这些代表错误的常量，但却无法改变它们。**
    - **我们可以仿照这种声明方式来构建我们自己的错误值列表，这样就可以保证错误值的只读特性了。**
    - 不过需要注意的是，**如果它们是公开的，那就应该尽量让它们成为常量而不是变量，或者编写私有的错误值以及公开的获取和判等函数，否则就很难避免恶意的篡改。**
    - 这其实是“**最小化访问权限”**这个程序设计原则的一个具体体现。无论怎样设计程序错误体系，我们都应该把这一点考虑在内。





# panic、recover以及defer

- 运行时恐慌 panic

  - 这种异常只会在程序运行的时候被抛出来（例如数组越界）。
  - 当 panic 被抛出之后，如果我们没有在程序里添加任何保护措施的话，程序（或者说代表它的那个进程）就会在打印出 panic 的详细情况（以下简称 panic 详情）之后，终止运行。

- 从 panic 被引发到程序终止运行的大致过程是什么

  - 大致的过程：某个函数中的某行代码有意或无意地引发了一个 panic。这时，初始的 panic 详情会被建立起来，并且该程序的控制权会立即从此行代码转移至调用其所属函数的那行代码上，也就是调用栈中的上一级。
    - 这也意味着，此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻的停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一级地沿着调用栈的反方向传播至顶端，也就是我们编写的最外层函数那里。
    - **这里的最外层函数指的是`go`函数，对于主 goroutine 来说就是`main`函数。**但是控制权也不会停留在那里，而是**被 Go 语言运行时系统收回。**
  - **随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。**与此同时，在这个控制权传播的过程中，panic 详情会被逐渐地积累和完善，并会在程序终止之前被打印出来。

- 除此之外，我们还是可以有意地引发 panic

  - Go 语言的内建函数`panic`是专门用于引发 panic 的。`panic`函数使程序开发者可以在程序运行期间报告异常。
    - 注意，这与从函数返回错误值的意义是完全不同的。当我们的函数返回一个非`nil`的错误值时，函数的调用方有权选择不处理，并且不处理的后果往往是不致命的。
    - 但是，当一个 panic 发生时，如果我们不施加任何保护措施，那么导致的直接后果就是程序崩溃，就像前面描述的那样，这显然是致命的。
  - **panic 详情会在控制权传播的过程中，被逐渐地积累和完善，并且，控制权会一级一级地沿着调用栈的反方向传播至顶端。**

- 怎样让 panic 包含一个值，以及应该让它包含什么样的值

  - 在调用`panic`函数时，把某个值作为参数传给该函数就可以了。**由于`panic`函数的唯一一个参数是空接口（也就是`interface{}`）类型的，所以从语法上讲，它可以接受任何类型的值。**
  - **但是，我们最好传入`error`类型的错误值，或者其他的可以被有效序列化的值**。这里的“有效序列化”指的是，可以更易读地去表示形式转换。
  - **对于`fmt`包下的各种打印函数来说，`error`类型值的`Error`方法与其他类型值的`String`方法是等价的**，它们的唯一结果都是`string`类型的。
  - 所以，如果你觉得某个值有可能会被**记到日志里**，那么就应该为它关联`String`方法。如果这个值是`error`类型的，那么让它的`Error`方法返回你为它定制的字符串表示形式就可以了。

- 怎样施加应对 panic 的保护措施，从而避免程序崩溃

  - Go 语言的内建函数`recover`专用于恢复 panic，或者说平息运行时恐慌。**`recover`函数无需任何参数，并且会返回一个空接口类型的值。**
  - panic 一旦发生，控制权就会讯速地沿着调用栈的反方向传播。所以，**在`panic`函数调用之后的代码，根本就没有执行的机会。**

- 到底什么才是正确的`recover`函数用法呢？这就不得不提到`defer`语句了。

  - `defer`语句就是被用来延迟执行代码的。**注意，被延迟执行的是`defer`函数，而不是`defer`语句。**延迟到什么时候呢？这要**延迟到该语句所在的函数即将执行结束的那一刻，无论结束执行的原因是什么。**

  - 一个`defer`语句总是由一个`defer`关键字和一个调用表达式组成。

  - ```go
     
    func main() {
     fmt.Println("Enter function main.")
     defer func(){
      fmt.Println("Enter defer function.")
      if p := recover(); p != nil {
       fmt.Printf("panic: %s\n", p)
      }
      fmt.Println("Exit defer function.")
     }()
     // 引发 panic。
     panic(errors.New("something wrong"))
     fmt.Println("Exit function main.")
    }
    ```

- 如果一个函数中有多条`defer`语句，那么那几个`defer`函数调用的执行顺序是怎样的？

  - 在同一个函数中，`defer`函数调用的执行顺序与它们分别所属的`defer`语句的出现顺序（更严谨地说，是执行顺序）**完全相反**。
  - 当一个函数即将结束执行时，其中的写在最下边的`defer`函数调用会最先执行，其次是写在它上边、与它的距离最近的那个`defer`函数调用，以此类推，最上边的`defer`函数调用会最后一个执行。

- `defer`语句执行时发生的事情

  - 在`defer`语句每次执行的时候，Go 语言会把它携带的`defer`函数及其参数值另行存储到一个队列中。
  - 这个队列与该`defer`语句所属的函数是对应的，并且，它是先进后出（FILO）的，相**当于一个栈**。

- 我们可以在`defer`函数中恢复 panic，那么可以在其中引发 panic 吗

  - 如果defer中引发panic，那么在该段defer函数之前，需要另外一个defer来捕获该panic，并且代码中最后一个panic会被抛弃，由defer中的panic来成为最后的异常返回。

- 从语言设计上，不使用try-catch而是用defer-recover有什么优势

  -  这是两种完全不同的异常处理机制。Go语言的异常处理机制是两层的，defer和recover可以处理意外的的异常，而error接口及相关体系处理可预期的异常。
  -  我认为defer机制正是建立在goroutine机制之上的。因为每个函数都有可能成为go函数，所以**必须要把异常处理做到函数级别。**可以看到，**defer机制和error机制**都是以函数为边界的。**前者在函数级别上阻止会导致非正常控制流的意外异常外溢，而后者在函数级别上用正常的控制流向外传递可预期异常。**
  -  defer是用来做函数级别的资源清理工作的，处理panic是兼职。





# 测试的基本规则和流程

- 我们可以为 Go 程序编写三类测试，即：功能测试（test）、基准测试（benchmark，也称性能测试），以及示例测试（example）。

- Go 语言对测试函数的名称和签名都有哪些规定

  - **对于功能测试函数来说，其名称必须以`Test`为前缀**，并且参数列表中只应有一个`*testing.T`类型的参数声明。
  - **对于性能测试函数来说，其名称必须以`Benchmark`为前缀**，并且唯一参数的类型必须是`*testing.B`类型的。
  - **对于示例测试函数来说，其名称必须以`Example`为前缀**，但对函数的参数列表没有强制规定。

- `go test`命令执行的主要测试流程是什么

  - `go test`命令在开始运行时，会先做一些准备工作，比如，确定内部需要用到的命令，检查我们指定的代码包或源码文件的有效性，以及判断我们给予的标记是否合法，等等。
  - 在准备工作顺利完成之后，`go test`命令就会针对每个被测代码包，**依次**地进行构建、执行包中符合要求的测试函数，清理临时文件，打印测试结果。这就是通常情况下的主要测试流程。
    - 但是，为了加快测试速度，它通常会**并发地对多个被测代码包进行功能测试**，只不过，在**最后打印测试结果的时候，它会依照我们给定的顺序逐个进行**，这会让我们感觉到它是在完全串行地执行测试流程。
    - 另一方面，**由于并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行进行的。**更具体地说，只有在所有构建步骤都做完之后，`go test`命令才会真正地开始进行性能测试。

- 怎样解释功能测试的测试结果

  - ```go
    $ go test puzzlers/article20/q2
    ok   puzzlers/article20/q2 (cached)
    ```

  - go 命令通常会缓存程序构建的结果，以便在将来的构建中重用。我们可以通过运行`go env GOCACHE`命令来查看缓存目录的路径。缓存的数据总是能够正确地反映出当时的各种源码文件、构建环境、编译器选项等等的真实情况。

  - 一旦有任何变动，缓存数据就会失效，go 命令就会再次真正地执行操作。所以我们并不用担心打印出的缓存数据不是实时的结果。go 命令会定期地删除最近未使用的缓存数据，但是，如果你想手动删除所有的缓存数据，运行一下`go clean -cache`命令就好了。

    - 此外，设置环境变量`GODEBUG`的值也可以稍稍地改变 go 命令的缓存行为。比如，**设置值为`gocacheverify=1`将会导致 go 命令绕过任何的缓存数据，而真正地执行操作并重新生成所有结果**，然后再去检查新的结果与现有的缓存数据是否一致。

  - **`t.Log`方法以及`t.Logf`方法**的作用，就是打印常规的测试日志，只不过当测试成功的时候，`go test`命令就不会打印这类日志了。如果你想在测试结果中看到所有的常规测试日志，那么可以在运行`go test`命令的时候加入标记`-v`。

    - 若我们想让某个测试函数在执行的过程中立即失败，则可以在该函数中调用`t.FailNow`方法。
    - 与`t.Fail()`不同，在`t.FailNow()`执行之后，当前函数会立即终止执行。换句话说，该行代码之后的所有代码都会失去执行机会。

- 怎样解释性能测试的测试结果

  - 我在运行`go test`命令的时候加了两个标记。**第一个标记及其值为`-bench=.`，只有有了这个标记，命令才会进行性能测试。**该标记的值`.`表明需要执行任意名称的性能测试函数

  - 第二个标记及其值是`-run=^$`，这个标记用于表明需要执行哪些功能测试函数，这同样也是以函数名称为依据的。**该标记的值`^$`意味着：只执行名称为空的功能测试函数，换句话说，不执行任何功能测试函数。**

  - 你可能已经看出来了，这两个标记的值都是**正则表达式**。实际上，它们只能以正则表达式为值。此外，如果运行`go test`命令的时候不加`-run`标记，那么就会使它执行被测代码包中的所有功能测试函数。

  - ```go
    $ go test -bench=. -run=^$ puzzlers/article20/q3
    goos: darwin
    goarch: amd64
    pkg: puzzlers/article20/q3
    BenchmarkGetPrimes-8      500000       2314 ns/op
    PASS
    ok   puzzlers/article20/q3 1.192s
    ```

    - **`BenchmarkGetPrimes-8`被称为单个性能测试的名称**，它表示命令执行了性能测试函数`BenchmarkGetPrimes`，并且当时所用的最大 P 数量为`8`。
      - **最大 P 数量相当于可以同时运行 goroutine 的逻辑 CPU 的最大个数**。这里的逻辑 CPU，也可以被称为 **CPU 核心**，但它**并不等同于计算机中真正的 CPU 核心**，**只是 Go 语言运行时系统内部的一个概念**，代表着它同时运行 goroutine 的能力。
      - 一台计算机的 CPU 核心的个数，意味着它能在同一时刻执行多少条程序指令，代表着它并行处理程序指令的能力。
      - 我们可以通过调用 `runtime.GOMAXPROCS`函数改变最大 P 数量，也可以在运行`go test`命令时，加入标记`-cpu`来设置一个最大 P 数量的列表，以供命令在多次测试时使用
    - 在性能测试名称右边的是，`go test`命令最后一次执行性能测试函数（即`BenchmarkGetPrimes`函数）的时候，**被测函数（即`GetPrimes`函数）被执行的实际次数。**
      - 但要注意，它指的是被测函数的执行次数，而不是性能测试函数的执行次数。
    - `2314 ns/op`表明单次执行`GetPrimes`函数的平均耗时为`2314`纳秒。这其实就是通过将最后一次执行测试函数时的执行时间，除以（被测函数的）执行次数而得出的。

- go help test

  - go test 的相关参数 可以用go help test去看
  - 一些更详细的参数说明需要敲 go help testflag 查看。
  - go test 也支持 go build 的一些参数，那些参数需要敲 go help build 查看，另外怎么指定代码包需要敲 go help packages 查看说明。





# 更多的测试手法

- `go test`命令的标记`-cpu`，它是用来设置测试执行最大 P 数量的列表的。

  -  P 是 processor 的缩写，每个 processor 都是一个可以承载若干个 G，且能够使这些 G 适时地与 M 进行对接并得到真正运行的中介。
  -  这里的 G 就是 goroutine 的缩写，可以被理解为 Go 语言自己实现的用户级线程。M 即为 machine 的缩写，代表着系统级线程，或者说操作系统内核级别的线程。
  -  P 的数量意味着 Go 程序背后的运行时系统中，会有多少个用于承载可运行的 G 的队列存在。每一个队列都相当于一条流水线，它会源源不断地把可运行的 G 输送给空闲的 M，并使这两者对接。
  -  因此，**最大 P 数量就代表着 Go 语言运行时系统同时运行 goroutine 的能力，也可以被视为其中逻辑 CPU 的最大个数。而`go test`命令的`-cpu`标记正是用于设置这个最大个数的。**
  -  在默认情况下，最大 P 数量就等于当前计算机 CPU 核心的实际数量。

- 怎样设置`-cpu`标记的值，以及它会对测试流程产生什么样的影响

  - 标记`-cpu`的值应该是一个正整数的列表，该列表的表现形式为：以英文半角逗号分隔的多个整数字面量，比如`1,2,4`。
  - **针对于此值中的每一个正整数，`go test`命令都会先设置最大 P 数量为该数，然后再执行测试函数。**
  - **如果测试函数有多个，那么`go test`命令会依照此方式逐个执行。**
    - 以`1,2,4`为例，`go test`命令会先以`1`,`2`,`4`为最大 P 数量分别去执行第一个测试函数，之后再用同样的方式执行第二个测试函数，以此类推。

- `go test`命令每一次对性能测试函数的执行，都是一个探索的过程。它会在测试函数的执行时间上限不变的前提下，尝试找到被测程序的最大执行次数。

  - 在这个过程中，性能测试函数可能会被执行多次。为了以后描述方便，我们把这样一个探索的过程称为：**对性能测试函数的一次探索式执行**，这其中包含了对该函数的若干次执行，当然，肯定也包括了对被测程序更多次的执行。

- `-count`标记是专门用于重复执行测试函数的。它的值必须大于或等于`0`，并且默认值为`1`。

  - 如果我们在运行`go test`命令的时候追加了`-count 5`，那么对于每一个测试函数，命令都会在预设的不同条件下（比如不同的最大 P 数量下）分别重复执行五次。
  - 性能测试函数的执行次数 = `-cpu`标记的值中正整数的个数 x `-count`标记的值 x 探索式执行中测试函数的实际执行次数
  - 功能测试函数的执行次数 = `-cpu`标记的值中正整数的个数 x `-count`标记的值

- **在对 Go 程序执行某种自动化测试的过程中，测试日志会显得特别多，而且好多都是重复的。**

  - **比如，对于功能测试函数来说，我们通常没有必要重复执行它**，即使是在不同的最大 P 数量下也是如此。注意，这里所说的重复执行指的是，在被测程序的输入（比如说被测函数的参数值）相同情况下的多次执行。
    - 还有些时候，我们的程序会无法避免地依赖一些外部环境，比如数据库或者其他服务。这时，我们依然不应该让测试的反复执行成为检测手段，而应该在测试中通过仿造（mock）外部环境，来规避掉它们的不确定性。
  - **正好相反，对于性能测试函数来说，我们常常需要反复地执行**，并以此试图抹平当时的计算资源调度的细微差别对被测程序性能的影响。通过`-cpu`标记，我们还能够模拟被测程序在计算能力不同计算机中的性能表现。

- `-parallel`标记的作用是什么

  - 该标记的作用是：设置同一个被测代码包中的**功能测试函数的最大并发执行数**。该标记的默认值是测试运行时的最大 P 数量
  - `-parallel`标记对性能测试是无效的。当然了，对于性能测试来说，也是可以并发进行的，不过机制上会有所不同。

- 性能测试函数中的计时器是做什么用的

  - `testing.B`类型有这么几个指针方法：`StartTimer`、`StopTimer`和`ResetTimer`。这些方法都是用于操作当前的性能测试函数专属的计时器的。

  - 所谓的计时器，是一个逻辑上的概念，它其实是`testing.B`类型中一些字段的统称。这些字段用于记录：**当前测试函数在当次执行过程中耗费的时间、分配的堆内存的字节数以及分配次数。**

  - 试函数中，我们可以通过对`b.StartTimer`和`b.StopTimer`方法的联合运用，再去除掉任何一段代码的执行时间。

    - ```go
      // 先停止了当前测试函数的计时器，然后通过调用time.Sleep函数，模拟了一个比较耗时的额外操作，并且在给变量max赋值之后又启动了该计时器。
      func BenchmarkGetPrimes(b *testing.B) {
       b.StopTimer()
       time.Sleep(time.Millisecond * 500) // 模拟某个耗时但与被测程序关系不大的操作。
       max := 10000
       b.StartTimer()
       
       for i := 0; i < b.N; i++ {
        GetPrimes(max)
       }
      }
      ```

- `-benchmem`标记和`-benchtime`标记的作用分别是什么？

  - -benchmem 输出基准测试的**内存分配统计信息**。
  - -benchtime 用于**指定基准测试的探索式测试执行时间上限**

- 怎样在测试的时候开启测试覆盖度分析？如果开启，会有什么副作用吗？

  - **使用 -coverprofile=xxxx.out 输出覆盖率的out文件**，使用go tool cover -html=xxxx.out 命令转换成Html的覆盖率测试报告。
  - 覆盖率测试将被测试的代码拷贝一份，在每个语句块中加入bool标识变量，测试结束后统计覆盖率并输出成out文件，因此性能上会有一定的影响。
  - PS：**使用-covermode=count标识参数将插入的标识变量由bool类型转换为计数器**，在测试过程中，记录执行次数，用于找出被频繁执行的代码块，方便优化。




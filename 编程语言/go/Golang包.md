# unicode与字符编码

- Go 语言字符编码基础

  - **Go 语言采用的字符编码方案从属于 Unicode 编码规范。**更确切地说，Go 语言的代码正是由 Unicode 字符组成的。Go 语言的所有源代码，都必须按照 Unicode 编码规范中的 UTF-8 编码格式进行编码。
  - **换句话说，Go 语言的源码文件必须使用 UTF-8 编码格式进行存储**。如果源码文件中出现了非 UTF-8 编码的字符，那么在构建、安装以及运行的时候，go 命令就会报告错误“illegal UTF-8 encoding”。

-  ASCII 编码

  - **ASCII 编码方案使用单个字节（byte）的二进制数来编码一个字符。**标准的 ASCII 编码用一个字节的最高比特（bit）位作为奇偶校验位，而扩展的 ASCII 编码则将此位也用于表示字符。ASCII 编码支持的可打印字符和控制字符的集合也被叫做 ASCII 编码集。
  - **我们所说的 Unicode 编码规范，实际上是另一个更加通用的、针对书面字符和文本的字符编码标准。**它为世界上现存的所有自然语言中的每一个字符，都设定了一个唯一的二进制编码。
  - **Unicode 编码规范以 ASCII 编码集为出发点，并突破了 ASCII 只能对拉丁字母进行编码的限制。**

- Unicode 编码规范提供了三种不同的编码格式，即：UTF-8、UTF-16 和 UTF-32。

  - 在这几种编码格式的名称中，**“-”右边的整数的含义是，以多少个比特位作为一个编码单元**。以 UTF-8 为例，它会以 8 个比特，也就是一个字节，作为一个编码单元。
  - **UTF-8 是一种可变宽的编码方案。**换句话说，它会用一个或多个字节的二进制数来表示某个字符，最多使用四个字节。比如，对于一个英文字符，它仅用一个字节的二进制数就可以表示，而对于一个中文字符，它需要使用三个字节才能够表示。不论怎样，一个受支持的字符总是可以由 UTF-8 编码为一个字节序列。

- 一个`string`类型的值在底层是怎样被表达的

  - 在底层，一个`string`类型的值是由一系列相对应的 Unicode 代码点的 UTF-8 编码值来表达的。

  - 在 Go 语言中，**一个`string`类型的值既可以被拆分为一个包含多个字符的序列，也可以被拆分为一个包含多个字节的序列。**

    - 前者可以由一个以`rune`为元素类型的切片来表示，而后者则可以由一个以`byte`为元素类型的切片代表。

  - ```go
    str := "Go 爱好者 "
    fmt.Printf("The string: %q\n", str)
    fmt.Printf("  => runes(char): %q\n", []rune(str))
    fmt.Printf("  => runes(hex): %x\n", []rune(str))
    fmt.Printf("  => bytes(hex): [% x]\n", []byte(str))
    
    => runes(char): ['G' 'o' '爱' '好' '者']
    // 一个`string`类型的值会由若干个 Unicode 字符组成，**每个 Unicode 字符都可以由一个`rune`类型的值来承载。**
    // 每个rune类型的值在底层都是由一个 UTF-8 编码值来表达的，所以我们可以换一种方式来展现这个字符序列
    //  rune的底层表达使用的是Unicode代码点。但是，底层的存储用UTF-8编码。
    => runes(hex): [47 6f 7231 597d 8005]
    // 我们还可以进一步地拆分，把每个字符的 UTF-8 编码值都拆成相应的字节序列。
    => bytes(hex): [47 6f e7 88 b1 e5 a5 bd e8 80 85]
    
    ```

- 使用带有`range`子句的`for`语句遍历字符串值的时候应该注意什么

  - **带有`range`子句的`for`语句会先把被遍历的字符串值拆成一个字节序列**，然后再试图找出这个字节序列中包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符。

  - 这样的`for`语句可以为两个迭代变量赋值。如果存在两个迭代变量，那么**赋给第一个变量的值，就将会是当前字节序列中的某个 UTF-8 编码值的第一个字节所对应的那个索引值。**

  - 这样的`for`语句可以逐一地迭代出字符串值里的每个 Unicode 字符。但是，相邻的 Unicode 字符的索引值并不一定是连续的。这取决于前一个 Unicode 字符是否为单字节字符。

    - ```go
      str := "Go 爱好者 "
      for i, c := range str {
       fmt.Printf("%d: %q [% x]\n", i, c, []byte(string(c)))
      }
      
      0: 'G' [47]
      1: 'o' [6f]
      2: '爱' [e7 88 b1]
      // 正是因为'爱'是由三个字节共同表达的，所以第四个 Unicode 字符'好'对应的索引值并不是3，而是2加3后得到的5。
      5: '好' [e5 a5 bd]
      8: '者' [e8 80 85]
      
      ```

    - 正因为如此，如果我们想得到其中某个 Unicode 字符对应的 UTF-8 编码值的宽度，就可以用下一个字符的索引值减去当前字符的索引值。

- 判断一个 Unicode 字符是否为单字节字符通常有几种方式

  - `unicode/utf8`代码包中有几个可以做此判断的函数，比如：`RuneLen`函数、`EncodeRune`函数等。我们需要根据输入的不同来选择和使用它们。具体可以查看该代码包的文档。

- utf8要做的就是怎么去判断一个字符到底用了几个字节存储，就好比买绳子一样，有的人要两米有的人要一米，不按照尺寸剪肯定不行，具体怎么减咱们先不关心这个留给utf8去处理。存储这些编码在计算机里就是二进制。这些二进制utf8能读懂，但是计算机看来就是01没啥了不起的，8二进制放到4字节存储没毛病吧，装不满的高位大不了填充0，就是这么有钱豆浆喝一杯倒一杯，这个就是[]rune, 但是世界总有吃不饱饭的人看着闹心，那还是一个字节一个字节存吧，等需要查看字符的时候大不了再转换为rune切片，这就是[]byte





# strings包与字符串操作

- 标准库中的`strings`代码包。这个代码包也用到了不少`unicode`包和`unicode/utf8`包中的程序实体。

  - 比如，`strings.Builder`类型的`WriteRune`方法。
  - 又比如，`strings.Reader`类型的`ReadRune`方法，等等。

- 与`string`值相比，`strings.Builder`类型的值有哪些**优势**？

  - 已存在的内容不可变，但可以拼接更多的内容；
  - 减少了内存分配和内容拷贝的次数；
  - 可将内容重置，可重用值。

- 在 Go 语言中，**`string`类型的值是不可变的**。 如果我们想获得一个不一样的字符串，那么就只能基于原字符串进行**裁剪、拼接**等操作，从而生成一个新的字符串。

  - 裁剪操作可以使用切片表达式；
  - 拼接操作可以用操作符`+`实现。

- 在底层，一个`string`值的内容会被**存储到一块连续的内存空间中**。同时，这块内存容纳的**字节数量也会被记录下来**，并用于表示该`string`值的长度。

  - **你可以把这块内存的内容看成一个字节数组**，而相应的`string`值则包含了指向字节数组头部的指针值。如此一来，我们在一个`string`值上应用切片表达式，就相当于在对其底层的字节数组做切片。
  - 另外，我们在进行字符串拼接的时候，Go 语言会把所有被拼接的字符串**依次拷贝到一个崭新且足够大的连续内存空间中**，并把持有相应指针值的`string`值作为结果返回。

- 注意，虽然`string`值在内部持有一个指针值，但其类型**仍然属于值类型**。不过，由于`string`值的不可变，其中的指针值也为内存空间的节省做出了贡献。

  - **更具体地说，一个`string`值会在底层与它的所有副本共用同一个字节数组。**由于这里的字节数组永远不会被改变，所以这样做是绝对安全的。

- **与`string`值相比，`Builder`值的优势其实主要体现在字符串拼接方面**

  - `Builder`值中有一个用于承载内容的**容器**（以下简称内容容器）。它是一个**以`byte`为元素类型的切片**（以下简称字节切片）。

  - 由于这样的字节切片的底层数组就是一个**字节数组**，所以我们可以说它与`string`值存储内容的方式是一样的。

  - 实际上，它们都是通过一个**`unsafe.Pointer`类型的字段**来持有那个指向了底层字节数组的指针值的。

  - 虽然，对于字节切片本身来说，它包含的任何元素值都可以被修改，但是**`Builder`值并不允许这样做，其中的内容只能够被拼接或者完全重置**。

    - 这就意味着，已存在于`Builder`值中的内容是不可变的。因此，我们可以利用`Builder`值提供的方法拼接更多的内容，而**丝毫不用担心这些方法会影响到已存在的内容。**

    - > 这里所说的方法指的是，`Builder`值拥有的一系列指针方法，包括：`Write`、`WriteByte`、`WriteRune`和`WriteString`。我们可以把它们统称为拼接方法。

    - 如有必要，`Builder`值会自动地对自身的内容容器进行扩容。这里的自动扩容策略与切片的扩容策略一致。

    - **除了`Builder`值的自动扩容，我们还可以选择手动扩容**，这通过调用`Builder`值的`Grow`方法就可以做到。`Grow`方法也可以被称为扩容方法，它接受一个`int`类型的参数`n`，该参数用于代表将要扩充的字节数量。

- 最后，`Builder`值是可以被重用的。通过调用它的`Reset`方法，我们可以让`Builder`值重新回到零值状态，就像它从未被使用过那样。

  - 一旦被重用，`Builder`值中原有的内容容器会被直接丢弃。之后，它和其中的所有内容，将会被 Go 语言的垃圾回收器标记并回收掉。

- `strings.Builder`类型在使用上有约束吗

  - 有约束，概括如下：

    - 在已被**真正使用后就不可再被复制**；

      - 我们只要调用了`Builder`值的拼接方法或扩容方法，就意味着开始真正使用它了。显而易见，这些方法都会改变其所属值中的内容容器的状态。

      - 一旦调用了它们，我们就不能再以任何的方式对其所属值进行复制了。否则，只要在任何副本上调用上述方法就都会引发 panic。

      - **这里所说的复制方式，包括但不限于在函数间传递值、通过通道传递值、把值赋予变量等等。**

      - ```go
        var builder1 strings.Builder
        builder1.Grow(1)
        builder3 := builder1
        //builder3.Grow(1) // 这里会引发 panic。
        _ = builder3
        ```

      - **不过，虽然已使用的`Builder`值不能再被复制，但是它的指针值却可以**。无论什么时候，我们都可以通过任何方式复制这样的指针值。注意，这样的指针值指向的都会是同一个`Builder`值。

    - 由于其内容不是完全不可变的，所以需要使用方**自行解决操作冲突和并发安全问题。**

      - **如果`Builder`值被多方同时操作，那么其中的内容就很可能会产生混乱**。这就是我们所说的操作冲突和并发安全问题。

      - ```go
        f2 := func(bp *strings.Builder) {
         (*bp).Grow(1) // 这里虽然不会引发 panic，但不是并发安全的。
         builder4 := *bp
         //builder4.Grow(1) // 这里会引发 panic。
         _ = builder4
        }
        f2(&builder1)
        ```

      - `Builder`值自己是无法解决这些问题的。所以，我们在通过传递其指针值共享`Builder`值的时候，一定要确保各方对它的使用是正确、有序的，并且是并发安全的；而**最彻底的解决方案是，绝不共享`Builder`值以及它的指针值。**

      - 我们可以在各处分别声明一个`Builder`值来使用，也可以先声明一个`Builder`值，然后在真正使用它之前，便将它的副本传到各处。另外，我们还可以先使用再传递，只要在传递之前调用它的`Reset`方法即可。

        ```go
        builder1.Reset()
        builder5 := builder1
        builder5.Grow(1) // 这里不会引发 panic。
        ```

- 为什么说`strings.Reader`类型的值可以**高效地读取字符串**

  - 与`strings.Builder`类型恰恰相反，`strings.Reader`类型是为了高效读取字符串而存在的。后者的高效主要体现在它**对字符串的读取机制上**，**它封装了很多用于在`string`值上读取内容的最佳实践。**
  - `strings.Reader`类型的值（以下简称`Reader`值）可以让我们很方便地读取一个字符串中的内容。在读取的过程中，`Reader`值会**保存已读取的字节的计数（以下简称已读计数）。**
  - 已读计数也代表着**下一次读取的起始索引位置**。`Reader`值正是依靠这样一个计数，以及**针对字符串值的切片表达式**，从而**实现快速读取**。
    - `Reader`值拥有的大部分用于读取的方法都会及时地更新已读计数。比如，**`ReadByte`方法**会在读取成功后**将这个计数的值加`1`**。
    - 又比如，**`ReadRune`方法**在读取成功之后，会**把被读取的字符所占用的字节数作为计数的增量。**
    - 不过，**`ReadAt`方法**算是一个例外。它既不会依据已读计数进行读取，也不会在读取后更新它。正因为如此，**这个方法可以自由地读取其所属的`Reader`值中的任何内容。**
    - 除此之外，`Reader`值的**`Seek`方法**也会更新该值的已读计数。实际上，这个`Seek`方法的**主要作用正是设定下一次读取的起始索引位置**。
      - 另外，如果我们把常量`io.SeekCurrent`的值作为第二个参数值传给该方法，那么它还会依据当前的已读计数，以及第一个参数`offset`的值来计算新的计数值。
  - 综上所述，`Reader`值实现高效读取的关键就在于它内部的已读计数。

- `*strings.Builder`和`*strings.Reader`都分别实现了哪些接口？这样做有什么好处吗？

  - string拼接的结果是**生成新的string**，需要把原字符串拷贝到新的string中；Builder底层有个[]byte,**按需扩容，不必每次拼接都需要拷贝**；
  - Reader的优势是维护一个已读计数器，知道下一次读的位置，**读得更快**.





# bytes包与字节串操作

- `bytes.Buffer`

  - `strings`包主要面向的是 Unicode **字符**和经过 UTF-8 编码的**字符串**，而`bytes`包面对的则主要是**字节和字节切片**。
  - `bytes.Buffer`类型的用途主要是作为**字节序列的缓冲区**。
  - `strings.Builder`只能拼接和导出字符串，而`bytes.Buffer`不但可以拼接、截断其中的字节序列，以各种形式导出其中的内容，还可以顺序地读取其中的子序列。
    - **可以说，`bytes.Buffer`是集读、写功能于一身的数据类型**。当然了，这些也基本上都是作为一个缓冲区应该拥有的功能。
  - **在内部，`bytes.Buffer`类型同样是使用字节切片作为内容容器的**。并且，与`strings.Reader`类型类似，`bytes.Buffer`有一个`int`类型的字段，用于代表已读字节的计数，可以简称为已读计数。
  - **不过，这里的已读计数就无法通过`bytes.Buffer`提供的方法计算出来了**
    - 实际上，与`strings.Reader`类型的`Len`方法一样，`buffer1`的`Len`方法返回的也是内容容器中未被读取部分的长度，而不是其中已存内容的总长度（以下简称内容长度）。
    - **总之，在这里，你需要记住的是，`Buffer`值的长度是未读内容的长度，而不是已存内容的总长度。**
    - 而`Buffer`值的**容量指的是它的内容容器（也就是那个字节切片）的容量**，它只与在当前值之上的写操作有关，并会随着内容的写入而不断增长。
  - 再说已读计数。由于`strings.Reader`还有一个`Size`方法可以给出内容长度的值，所以我们用内容长度减去未读部分的长度，就可以很方便地得到它的已读计数。
    - 然而，`bytes.Buffer`类型却没有这样一个方法，它只有`Cap`方法。**可是`Cap`方法提供的是内容容器的容量，也不是内容长度。**

- `bytes.Buffer`类型的值记录的**已读计数，在其中起到了怎样的作用**

  - **`bytes.Buffer`的绝大多数方法都用到了已读计数，而且都是非用不可。**
  - `bytes.Buffer`中的已读计数的大致功用如下所示。
    1. 读取内容时，相应方法会依据已读计数找到未读部分，并在读取后更新计数。
       1. **在读取内容的时候**，相应方法会先根据已读计数，判断一下内容容器中是否还有未读的内容。如果有，那么它就会从已读计数代表的索引处开始读取。
       2. **在读取完成后**，它还会及时地更新已读计数。也就是说，它会记录一下又有多少个字节被读取了。**这里所说的相应方法包括了所有名称以`Read`开头的方法，以及`Next`方法和`WriteTo`方法。**
    2. 写入内容时，如需扩容，相应方法会根据已读计数实现扩容策略。
       1. **在写入内容的时候**，绝大多数的相应方法都会先检查当前的内容容器，是否有足够的容量容纳新的内容。如果没有，那么它们就会对内容容器进行扩容。
       2. **在扩容的时候**，方法会在必要时，依据已读计数找到未读部分，并把其中的内容拷贝到扩容后内容容器的头部位置。
       3. 然后，方法将会把已读计数的值置为`0`，以表示下一次读取需要从内容容器的第一个字节开始。**用于写入内容的相应方法，包括了所有名称以`Write`开头的方法，以及`ReadFrom`方法。**
    3. 截断内容时，相应方法截掉的是已读计数代表索引之后的未读部分。
       1. 用于截断内容的方法`Truncate`，它会接受一个`int`类型的参数，这个参数的值代表了：**在截断时需要保留头部的多少个字节**。
       2. 不过，需要注意的是，这里说的头部指的并不是内容容器的头部，而是其中的**未读部分的头部**。头部的起始索引正是由已读计数的值表示的。因此，**在这种情况下，已读计数的值再加上参数值后得到的和，就是内容容器新的总长度。**
    4. 读回退时，相应方法需要用已读计数记录回退点。
       1. **在`bytes.Buffer`中，用于读回退的方法有`UnreadByte`和`UnreadRune`。** 这两个方法分别用于回退一个字节和回退一个 Unicode 字符。调用它们一般都是为了退回在上一次被读取内容末尾的那个分隔符，或者为重新读取前一个字节或字符做准备。
       2. **不过，退回的前提是，在调用它们之前的那一个操作必须是“读取”，并且是成功的读取**，否则这些方法就只能忽略后续操作并返回一个非`nil`的错误值。
    5. 重置内容时，相应方法会把已读计数置为`0`。
    6. 导出内容时，相应方法只会导出已读计数代表的索引之后的未读部分。
    7. 获取长度时，相应方法会依据已读计数和内容容器的长度，计算未读部分的长度并返回。
       1. 该类型的`Bytes`方法和`String`方法的行为，与`Len`方法是保持一致的。前两个方法只会去访问未读部分中的内容，并返回相应的结果值。
       2. String和Bytes方法不会更新内部计数器off

- `bytes.Buffer`的扩容策略是怎样的

  - `Buffer`值既可以被手动扩容，也可以进行自动扩容。并且，这两种扩容方式的策略是基本一致的。所以，除非我们完全确定后续内容所需的字节数，否则让`Buffer`值自动去扩容就好了。

  - 在扩容的时候，`Buffer`值中相应的代码（以下简称扩容代码）会**先判断内容容器的剩余容量**，是否可以满足调用方的要求，或者是否足够容纳新的内容。

    - **如果可以，那么扩容代码会在当前的内容容器之上，进行长度扩充。**

      - 更具体地说，如果内容容器的容量与其长度的差，大于或等于另需的字节数，那么扩容代码就会通过切片操作对原有的内容容器的长度进行扩充，就像下面这样：

      - > b.buf = b.buf[:length+need]

    - **反之，如果内容容器的剩余容量不够了，那么扩容代码可能就会用新的内容容器去替代原有的内容容器，从而实现扩容。**

      - **如果当前内容容器的容量的一半，仍然大于或等于其现有长度再加上另需的字节数的和**，即：

        - > cap(b.buf)/2 >= len(b.buf)+need

        - **那么，扩容代码就会复用现有的内容容器，并把容器中的未读内容拷贝到它的头部位置。**

        - 这也意味着其中的已读内容，将会全部被未读内容和之后的新内容覆盖掉。

        - 这样的复用预计可以至少节省掉一次后续的扩容所带来的内存分配，以及若干字节的拷贝。

      - **若这一步优化未能达成**，也就是说，当前内容容器的容量小于新长度的二倍。

        - 那么，扩容代码就只能再创建一个新的内容容器，并把原有容器中的未读内容拷贝进去，最后再用新的容器替换掉原有的容器。这个新容器的容量将会等于原有容量的二倍再加上另需字节数的和。

        - > 新容器的容量 =2* 原有容量 + 所需字节数

    - **通过上面这些步骤，对内容容器的扩充基本上就完成了。**不过，为了内部数据的一致性，以及避免原有的已读内容可能造成的数据混乱，**扩容代码还会把已读计数置为`0`，并再对内容容器做一下切片操作，以掩盖掉原有的已读内容。**

      - 顺便说一下，对于处在零值状态的`Buffer`值来说，**如果第一次扩容时的另需字节数不大于`64`，那么该值就会基于一个预先定义好的、长度为`64`的字节数组来创建内容容器。**
      - 在这种情况下，这个内容容器的容量就是`64`。这样做的目的是为了让`Buffer`值在刚被真正使用的时候就可以快速地做好准备。

- `bytes.Buffer`中的哪些方法可能会造成内容的泄露

  - 这里所说的内容泄露是指，使用`Buffer`值的一方通过某种非标准的（或者说不正式的）方式，**得到了本不该得到的内容。**

  - 在`bytes.Buffer`中，**`Bytes`方法和`Next`方法**都可能会造成内容的泄露。原因在于，**它们都把基于内容容器的切片直接返回给了方法的调用方。**

  - 在这里，`Bytes`方法和`Next`方法返回的字节切片，都是通过对内容容器做切片操作得到的。也就是说，它们与内容容器共用了同一个底层数组，起码在一段时期之内是这样的。

  - ```go
    // 以Bytes方法为例。它会返回在调用那一刻其所属值中的所有未读内容。
    contents := "ab"
    buffer1 := bytes.NewBufferString(contents)
    fmt.Printf("The capacity of new buffer with contents %q: %d\n",
     contents, buffer1.Cap()) // 内容容器的容量为：8。
    unreadBytes := buffer1.Bytes()
    fmt.Printf("The unread bytes of the buffer: %v\n", unreadBytes) // 未读内容为：[97 98]。
    
    // 又向该值写入了字符串值"cdefg"，此时，其容量仍然是8。我在前面通过调用buffer1的Bytes方法得到的结果值unreadBytes，包含了在那时其中的所有未读内容。
    // 但是，由于这个结果值与buffer1的内容容器在此时还共用着同一个底层数组，所以，我只需通过简单的再切片操作，就可以利用这个结果值拿到buffer1在此时的所有未读内容。如此一来，buffer1的新内容就被泄露出来了
    buffer1.WriteString("cdefg")
    fmt.Printf("The capacity of buffer: %d\n", buffer1.Cap()) // 内容容器的容量仍为：8。
    unreadBytes = unreadBytes[:cap(unreadBytes)]
    fmt.Printf("The unread bytes of the buffer: %v\n", unreadBytes) // 基于前面获取到的结果值可得，未读内容为：[97 98 99 100 101 102 103 0]。
    
    // 如果我当时把unreadBytes的值传到了外界，那么外界就可以通过该值操纵buffer1的内容了
    unreadBytes[len(unreadBytes)-2] = byte('X') // 'X'的 ASCII 编码为 88。
    fmt.Printf("The unread bytes of the buffer: %v\n", buffer1.Bytes()) // 未读内容变为了：[97 98 99 100 101 102 88]。
    
    // 不过，在buffer的内容容器真正扩容之后就无法这么做了。
    // 经过扩容，Buffer值的内容容器或者它的底层数组被重新设定了，那么之前的内容泄露问题就无法再进一步发展了。
    contents = "hijklmn"
    fmt.Printf("Write contents %q ...\n", contents)
    buffer1.WriteString(contents)
    fmt.Printf("The capacity of buffer: %d\n", buffer1.Cap())
    fmt.Println()
    
    unreadBytes = unreadBytes[:cap(unreadBytes)]
    fmt.Printf("The unread bytes of the buffer: %v\n", unreadBytes)
    fmt.Print("\n\n")
    
    
    
    
    ```

- 对比`strings.Builder`和`bytes.Buffer`的`String`方法，并判断哪一个更高效？原因是什么？

  - 我们可以直接查看两个String方法的源代码，其中strings.Builder String方法中
    *(*string)(unsafe.Pointer(&b.buf)) 是直接取得buf的地址然后转换成string返回。
    而bytes.Buffer的String方法是 string(b.buf[b.off:])
  - string(b.buf[b.off:])，这个是深拷贝，string()操作新建了一个底层数组，然后将b.buf的内容拷贝到新数组。而strings的方法是浅拷贝，所以性能会更高





# io包中的接口和工具

- **`strings.Builder`类型主要用于构建字符串**，它的指针类型实现的接口有`io.Writer`、`io.ByteWriter`和`fmt.Stringer`。另外，它其实还实现了一个`io`包的包级私有接口`io.stringWriter`（自 Go 1.12 起它会更名为`io.StringWriter`）。

- **`strings.Reader`类型主要用于读取字符串**，它的指针类型实现的接口比较多，包括：

  > 1. `io.Reader`；
  > 2. `io.ReaderAt`；
  > 3. `io.ByteReader`；
  > 4. `io.RuneReader`；
  > 5. `io.Seeker`；
  > 6. `io.ByteScanner`；
  > 7. `io.RuneScanner`；
  > 8. `io.WriterTo`；

  - 其中，`io.ByteScanner`是`io.ByteReader`的扩展接口，而`io.RuneScanner`又是`io.RuneReader`的扩展接口。

- **`bytes.Buffer`是集读、写功能于一身的数据类型，它非常适合作为字节序列的缓冲区。** 它的指针类型实现的接口就更多了。

  > 该指针类型实现的读取相关的接口有下面几个
  >
  > 1. `io.Reader`；
  > 2. `io.ByteReader`；
  > 3. `io.RuneReader`；
  > 4. `io.ByteScanner`；
  > 5. `io.RuneScanner`；
  > 6. `io.WriterTo`
  >
  > 
  >
  > 其实现的写入相关的接口则有这些
  >
  > 1. `io.Writer`；
  > 2. `io.ByteWriter`；
  > 3. `io.stringWriter`；
  > 4. `io.ReaderFrom`；

- io 包中接口的好处与优势

  - **简单地说，这是为了提高不同程序实体之间的互操作性。**
  - 在`io`包中，有这样几个用于拷贝数据的函数，它们是：
    - `io.Copy`；
    - `io.CopyBuffer`；
    - `io.CopyN`。
    - 虽然这几个函数在功能上都略有差别，但是它们都首先会接受两个参数，即：用于代表数据目的地、`io.Writer`类型的参数`dst`，以及用于代表数据来源的、`io.Reader`类型的参数`src`。这些函数的功能大致上都是把数据从`src`拷贝到`dst`。
    - 虽然，变量`src`和`dst`的类型分别是`strings.Reader`和`strings.Builder`，但是**当它们被传到`io.CopyN`函数的时候，就已经分别被包装成了`io.Reader`类型和`io.Writer`类型的值**。`io.CopyN`函数也根本不会去在意，它们的实际类型到底是什么。
  - 从总体上来看，这些代码都是面向参数声明中的接口来做的。**`io.CopyN`函数的作者通过面向接口编程，极大地拓展了它的适用范围和应用场景。**
  - 换个角度看，正因为`strings.Reader`类型和`strings.Builder`类型都实现了不少接口，所以它们的值才能够被使用在更广阔的场景中。
  - **换句话说，如此一来，Go 语言的各种库中，能够操作它们的函数和数据类型明显多了很多。**
    - 这就是我想要告诉你的，**`strings`包和`bytes`包中的数据类型在实现了若干接口之后得到的最大好处**。
    - 也可以说，这就是**面向接口编程**带来的最大优势。这些数据类型和函数的做法，也是非常值得我们在编程的过程中去效仿的。

- 在`io`包中，`io.Reader`的扩展接口和实现类型都有哪些？它们分别都有什么功用？

  - 在`io`包中，`io.Reader`的**扩展接口**有下面几种。

    - `io.ReadWriter`：此接口既是`io.Reader`的扩展接口，也是`io.Writer`的扩展接口。换句话说，**该接口定义了一组行为，包含且仅包含了基本的字节序列读取方法`Read`，和字节序列写入方法`Write`。**
    - `io.ReadCloser`：**此接口除了包含基本的字节序列读取方法之外，还拥有一个基本的关闭方法`Close`。后者一般用于关闭数据读写的通路**。这个接口其实是`io.Reader`接口和`io.Closer`接口的组合。
    - `io.ReadWriteCloser`：很明显，此接口是`io.Reader`、`io.Writer`和`io.Closer`这三个接口的组合。
    - `io.ReadSeeker`：此接口的**特点是拥有一个用于寻找读写位置的基本方法`Seek`。更具体地说，该方法可以根据给定的偏移量基于数据的起始位置、末尾位置，或者当前读写位置去寻找新的读写位置**。这个新的读写位置用于表明下一次读或写时的起始索引。`Seek`是`io.Seeker`接口唯一拥有的方法。
    - `io.ReadWriteSeeker`：显然，此接口是另一个三合一的扩展接口，它是`io.Reader`、`io.Writer`和`io.Seeker`的组合。

  - `io.Reader`接口的**实现类型**，它们包括下面几项内容

    - `*io.LimitedReader`：此类型的基本类型会包装`io.Reader`类型的值，并提供一个额外的**受限读取**的功能。所谓的受限读取指的是，此类型的读取方法`Read`返回的总数据量会受到限制，无论该方法被调用多少次。这个限制由该类型的字段`N`指明，单位是字节。

    - `*io.SectionReader`：此类型的基本类型可以包装`io.ReaderAt`类型的值，并且会**限制它的`Read`方法，只能够读取原始数据中的某一个部**分（或者说某一段）。

      - **这个数据段的起始位置和末尾位置，需要在它被初始化的时候就指明，并且之后无法变更。**该类型值的行为与切片有些类似，它只会对外暴露在其窗口之中的那些数据。

    - `*io.teeReader`：此类型是一个**包级私有**的数据类型，也是`io.TeeReader`函数结果值的实际类型。这个函数接受两个参数`r`和`w`，类型分别是`io.Reader`和`io.Writer`。

      - **其结果值的`Read`方法会把`r`中的数据经过作为方法参数的字节切片`p`写入到`w`。**可以说，这个值就是`r`和`w`之间的数据桥梁，而那个参数`p`就是这座桥上的数据搬运者。

    - `io.multiReader`：此类型也是一个**包级私有**的数据类型。类似的，`io`包中有一个名为`MultiReader`的函数，它可以**接受若干个`io.Reader`类型的参数值，并返回一个实际类型为`io.multiReader`的结果值。**

      - 当这个结果值的`Read`方法被调用时，它会顺序地从前面那些`io.Reader`类型的参数值中读取数据。因此，我们也可以称之为多对象读取器。

    - `io.pipe`：此类型为一个**包级私有**的数据类型，它比上述类型都要复杂得多。它不但实现了`io.Reader`接口，而且还实现了`io.Writer`接口。

      - 实际上，`io.PipeReader`类型和`io.PipeWriter`类型拥有的所有指针方法都是以它为基础的。这些方法都只是代理了`io.pipe`类型值所拥有的某一个方法而已。

      - 又因为`io.Pipe`函数会**返回这两个类型的指针值并分别把它们作为其生成的同步内存管道的两端，所以可以说，`*io.pipe`类型就是`io`包提供的同步内存管道的核心实现。**

    - `io.PipeReader`：此类型可以被视为`io.pipe`类型的代理类型。它代理了后者的一部分功能，并基于后者实现了`io.ReadCloser`接口。同时，它还定义了同步内存管道的读取端。

- `io`包中的接口都有哪些？它们之间都有着怎样的关系

  - 有的接口有着众多的扩展接口和实现类型，我们可以称之为**核心接口**。**`io`包中的核心接口只有 3 个，它们是：`io.Reader`、`io.Writer`和`io.Closer`。**
    - 我们还可以把`io`包中的简单接口分为四大类。这四大类接口分别针对于四种操作，即：读取、写入、关闭和读写位置设定。前三种操作属于基本的 I/O 操作。
  - **`io.Reader`。**它在`io`包中有 5 个扩展接口，并有 6 个实现类型。
    - `io.ByteReader`和`io.RuneReader`这两个简单接口。它们分别定义了一个读取方法，即：`ReadByte`和`ReadRune`。
      - **这两个读取方法分别只能够读取下一个单一的字节和 Unicode 字符。**
      - 数据类型`strings.Reader`和`bytes.Buffer`都是**`io.ByteReader`和`io.RuneReader`**的实现类型。
      - 不仅如此，这两个类型还都实现了**`io.ByteScanner`接口和`io.RuneScanner`接口。**
        - `io.ByteScanner`接口内嵌了简单接口`io.ByteReader`，并定义了额外的`UnreadByte`方法。如此一来，它就抽象出了一个能够读取和读回退单个字节的功能集。
        - 与之类似，`io.RuneScanner`内嵌了简单接口`io.RuneReader`，并定义了额外的`UnreadRune`方法。它抽象的是可以读取和读回退单个 Unicode 字符的功能集。
    - `io.ReaderAt`接口。它也是一个简单接口，其中只定义了一个方法`ReadAt`。与我们在前面说过的读取方法都不同，`ReadAt`是一个纯粹的只读方法。
    - 还有一个读取操作相关的接口我们没有介绍过，它就是**`io.WriterTo`。这个接口定义了一个名为`WriteTo`的方法。**
      - 这个`WriteTo`方法其实是一个**读取方法**。它会接受一个`io.Writer`类型的参数值，并会**把其所属值中的数据读出并写入到这个参数值中**。
      - 与之相对应的是`io.ReaderFrom`接口。它定义了一个名叫`ReadFrom`的写入方法。**该方法会接受一个`io.Reader`类型的参数值，并会从该参数值中读出数据, 并写入到其所属值中**。
  - **`io.Writer`**
    - 基于它的扩展接口除了有我们已知的`io.ReadWriter`、`io.ReadWriteCloser`和`io.ReadWriteSeeker`之外，还有`io.WriteCloser`和`io.WriteSeeker`。
    - 我们之前提及的**`*io.pipe`就是`io.ReadWriter`接口的实现类型。**然而，在`io`包中并没有`io.ReadWriteCloser`接口的实现，它的实现类型主要集中在`net`包中。
    - 除此之外，**写入操作相关的简单接口还有`io.ByteWriter`和`io.WriterAt`。**可惜，`io`包中也没有它们的实现类型。不过，有一个数据类型值得在这里提一句，那就是`*os.File`。
      - 这个类型不但是`io.WriterAt`接口的实现类型，还同时实现了`io.ReadWriteCloser`接口和`io.ReadWriteSeeker`接口。也就是说，该类型支持的 I/O 操作非常的丰富。
    - `io.Seeker`接口作为一个读写位置设定相关的简单接口，也仅仅定义了一个方法，名叫`Seek`。
  - 最后，关闭操作相关的接口`io.Closer`非常通用，它的扩展接口和实现类型都不少。

- 最后再强调一下，`io`包中的简单接口共有 11 个。其中，读取操作相关的接口有 5 个，写入操作相关的接口有 4 个，而与关闭操作有关的接口只有 1 个，另外还有一个读写位置设定相关的接口。







#  bufio包中的数据类型

- `bufio`包中的数据类型主要有：
  1. `Reader`；
  2. `Scanner`；
  3. `Writer`和`ReadWriter`。
- 与`io`包中的数据类型类似，这些类型的值也都需要在**初始化的时候，包装一个或多个简单 I/O 接口类型的值。**
- `bufio.Reader`类型值中的缓冲区起着怎样的作用
  - `bufio.Reader`类型的值（以下简称`Reader`值）内的缓冲区，其实就是一个数据存储中介
  - `Reader`值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂存于缓冲区之中以备后用。
- `bufio.Reader`类型并不是开箱即用的，因为它包含了一些需要显式初始化的字段
  - `buf`：`[]byte`类型的字段，即字节切片，代表缓冲区。虽然它是切片类型的，但是其长度却会在初始化的时候指定，并在之后保持不变。
  - `rd`：`io.Reader`类型的字段，代表底层读取器。缓冲区中的数据就是从这里拷贝来的。
  - `r`：`int`类型的字段，代表对缓冲区进行下一次读取时的开始索引。我们可以称它为已读计数。
  - `w`：`int`类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。
  - `err`：`error`类型的字段。它的值用于表示在从底层读取器获得数据时发生的错误。这里的值在被读取或忽略之后，该字段会被置为`nil`。
  - `lastByte`：`int`类型的字段，用于记录缓冲区中最后一个被读取的字节。读回退时会用到它的值。
  - `lastRuneSize`：`int`类型的字段，用于记录缓冲区中最后一个被读取的 Unicode 字符所占用的字节数。读回退的时候会用到它的值。这个字段只会在其所属值的`ReadRune`方法中才会被赋予有意义的值。在其他情况下，它都会被置为`-1`。
- `bufio`包为我们提供了两个用于初始化`Reader`值的函数，分别叫：
  - `NewReader`；
  - `NewReaderSize`；
    - `NewReader`函数初始化的`Reader`值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 4096 个字节，即：4 KB。而`NewReaderSize`函数则将缓冲区尺寸的决定权抛给了使用方。
- 在`bufio.Reader`类型拥有的读取方法中，**`Peek`方法和`ReadSlice`方法都会调用该类型一个名为`fill`的包级私有方法。`fill`方法的作用是填充内部缓冲区。**
  - `fill`方法会先检查其所属值的已读计数。如果这个计数不大于`0`，那么有两种可能。
    - 一种可能是其缓冲区中的字节都是全新的，也就是说它们都没有被读取过，另一种可能是缓冲区刚被压缩过。
    - 对缓冲区的压缩包括两个步骤。
      - 第一步，把缓冲区中在`[已读计数, 已写计数)`范围之内的所有元素值（或者说字节）都依次拷贝到缓冲区的头部。
      - 在压缩缓冲区的第二步中，`fill`方法会把已写计数的新值设定为原已写计数与原已读计数的差。这个差所代表的索引，就是压缩后第一次写入字节时的开始索引。
  - **实际上，`fill`方法只要在开始时发现其所属值的已读计数大于`0`，就会对缓冲区进行一次压缩。**之后，如果缓冲区中还有可写的位置，那么该方法就会对其进行**填充**。
  - 在填充缓冲区的时候，`fill`方法会试图从底层读取器那里，读取足够多的字节，并尽量把从已写计数代表的索引位置到缓冲区末尾之间的空间都填满。
  - 在这个过程中，`fill`方法会**及时地更新已写计数**，以保证填充的正确性和顺序性
- `bufio.Writer`类型值中缓冲的数据什么时候会被写到它的底层写入器
  - `bufio.Writer`类型都有哪些字段：
    1. `err`：`error`类型的字段。它的值用于表示在向底层写入器写数据时发生的错误。
    2. `buf`：`[]byte`类型的字段，代表缓冲区。在初始化之后，它的长度会保持不变。
    3. `n`：`int`类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。
    4. `wr`：`io.Writer`类型的字段，代表底层写入器。
  - `bufio.Writer`类型有一个名为**`Flush`的方法，它的主要功能是把相应缓冲区中暂存的所有数据，都写到底层写入器中。**数据一旦被写进底层写入器，该方法就会把它们从缓冲区中删除掉。
  - `bufio.Writer`类型值（以下简称`Writer`值）拥有的所有数据写入方法都会在必要的时候调用它的`Flush`方法。
    - 比如，**`Write`方法**有时候会在把数据写进缓冲区之后，调用`Flush`方法，以便为后续的新数据腾出空间。`WriteString`方法的行为与之类似。
      - 此外，如果`Write`方法**发现需要写入的字节太多，同时缓冲区已空**，那么它就会跨过缓冲区，并直接把这些数据写到底层写入器中。
    - 又比如，**`WriteByte`方法和`WriteRune`方法**，都会在发现缓冲区中的可写空间不足以容纳新的字节，或 Unicode 字符的时候，调用`Flush`方法。
    - 而**`ReadFrom`方法**，则会在发现底层写入器的类型是**`io.ReaderFrom`接口**的实现之后，直接调用其`ReadFrom`方法把参数值持有的数据写进去。
  - 总之，在通常情况下，**只要缓冲区中的可写空间无法容纳需要写入的新数据，`Flush`方法就一定会被调用**。并且，`bufio.Writer`类型的一些方法有时候还会**试图走捷径**，跨过缓冲区而直接对接数据供需的双方。
- `bufio.Reader`类型拥有很多用于读取数据的指针方法，**这里面有 4 个方法可以作为不同读取流程的代表，它们是：`Peek`、`Read`、`ReadSlice`和`ReadBytes`。**
  - **`Reader`值的`Peek`方法**的功能是：读取并返回其缓冲区中的`n`个未读字节，并且它会从已读计数代表的索引位置开始读。
    - **在缓冲区未被填满，并且其中的未读字节的数量小于`n`的时候，该方法就会调用`fill`方法，以启动缓冲区填充流程**。但是，如果它发现上次填充缓冲区的时候有错误，那就不会再次填充。
    - **如果调用方给定的`n`比缓冲区的长度还要大，或者缓冲区中未读字节的数量小于`n`**，那么`Peek`方法就会把“所有未读字节组成的序列”作为第一个结果值返回。
      - 同时，它通常还把“`bufio.ErrBufferFull`变量的值（以下简称缓冲区已满的错误）”作为第二个结果值返回，用来表示：虽然缓冲区被压缩和填满了，但是仍然满足不了要求。
    - 只有在上述的情况都没有出现时，`Peek`方法才能返回：“以已读计数为起始的`n`个字节”和“表示未发生任何错误的`nil`”。
  - `bufio.Reader`类型的 Peek 方法有一个鲜明的特点，那就是：**即使它读取了缓冲区中的数据，也不会更改已读计数的值。**
  - 就拿**该类型的`Read`方法来说**，它有时会把缓冲区中的未读字节，**依次拷贝到其参数`p`代表的字节切片中**，并立即根据实际拷贝的字节数增加已读计数的值。
    - **在缓冲区中还有未读字节的情况下，该方法的做法就是如此。**不过，在另一些时候，其所属值的已读计数会等于已写计数，这表明：此时的缓冲区中已经没有任何未读的字节了。
    - **当缓冲区中已无未读字节时，`Read`方法会先检查参数`p`的长度是否大于或等于缓冲区的长度。**如果是，那么`Read`方法会索性放弃向缓冲区中填充数据，转而直接从其底层读取器中读出数据并拷贝到`p`中。这意味着它完全跨过了缓冲区，并直连了数据供需的双方。
      - **如果缓冲区中已无未读字节，但其长度比参数`p`的长度更大**，那么该方法会先把已读计数和已写计数的值都重置为`0`，然后**再尝试**着使用从底层读取器那里获取的数据，对缓冲区进行一次从头至尾的填充。**不过要注意，这里的尝试只会进行一次。**
    - **`Read`方法在大多数的情况下，是不会向缓冲区中写入数据的，尤其是在前面描述的那种情况下**，即：缓冲区中已无未读字节，且参数`p`的长度大于或等于缓冲区的长度。
  - **`ReadSlice`方法和`ReadBytes`方法。** 这两个方法的功能总体上来说，都是持续地读取数据，直至遇到调用方给定的分隔符为止。
    - **`ReadSlice`方法**会先在其缓冲区的未读部分中寻找分隔符。如果未能找到，并且缓冲区未满，那么该方法会先通过调用`fill`方法对缓冲区进行填充，然后再次寻找，如此往复。
      - 如果在填充的过程中发生了错误，那么它会把**缓冲区中的未读部分作为结果返回，同时返回相应的错误值。**
      - 注意，**在这个过程中有可能会出现虽然缓冲区已被填满，但仍然没能找到分隔符的情况。**
        - 这时，`ReadSlice`方法会把**整个缓冲区**（也就是`buf`字段代表的字节切片）作为第一个结果值，并把缓冲区已满的错误（即`bufio.ErrBufferFull`变量的值）作为第二个结果值。
      - 当然了，**一旦`ReadSlice`方法找到了分隔符**，它就会在缓冲区上切出相应的、包含分隔符的字节切片，并**把该切片作为结果值返回**。
    - **`ReadBytes`方法**会通过调用`ReadSlice`方法一次又一次地从缓冲区中读取数据，直至找到分隔符为止。
      - 在这个过程中，`ReadSlice`方法可能会因缓冲区已满而返回所有已读到的字节和相应的错误值，但`ReadBytes`方法总是会忽略掉这样的错误，并再次调用`ReadSlice`方法，这使得后者会继续填充缓冲区并在其中寻找分隔符。
      - **除非`ReadSlice`方法返回的错误值并不代表缓冲区已满的错误，或者它找到了分隔符，否则这一过程永远不会结束。**
      - 如果寻找的过程结束了，不管是不是因为找到了分隔符，`ReadBytes`方法都**会把在这个过程中读到的所有字节，按照读取的先后顺序组装成一个字节切片，并把它作为第一个结果值**。如果过程结束是因为出现错误，那么它还会把拿到的错误值作为第二个结果值。
- `bufio.Reader`类型的`Peek`方法、`ReadSlice`方法和`ReadLine`方法都有可能会造成内容泄露。
  - 这主要是因为它们在正常的情况下都会**返回直接基于缓冲区的字节切片**。
  - 调用方可以通过这些方法返回的结果值访问到缓冲区的其他部分，甚至修改缓冲区中的内容。这通常都是很危险的。
- `bufio.Scanner`类型的主要功用是什么？它有哪些特点？
  - `bufio.Scanner`类型俗称带缓存的扫描器。它的功能还是比较强大的。
  - 比如，我们可以自定义每次扫描的边界，或者说内容的分段方法。我们在调用它的`Scan`方法对目标进行扫描之前，**可以先调用其`Split`方法并传入一个函数来自定义分段方法。**
  - 在默认情况下，扫描器会以行为单位对目标内容进行扫描。`bufio`代码包提供了一些现成的分段方法。**实际上，扫描器在默认情况下会使用`bufio.ScanLines`函数作为分段方法。**
  - 又比如，我们还可以在扫描之前自定义缓存的载体和缓存的最大容量，这需要调用它的`Buffer`方法。**在默认情况下，扫描器内部设定的最大缓存容量是`64K`个字节。**
    - **换句话说，目标内容中的每一段都不能超过`64K`个字节。否则，扫描器就会使它的`Scan`方法返回`false`**，并通过其`Err`方法给予我们一个表示“token too long”的错误值。这里的“token”代表的就是一段内容。



# 使用os包中的API 

- 这个代码包提供的都是**平台不相关的 API**

  - 它的意思是：这些 API 基于（或者说抽象自）操作系统，为我们使用操作系统的功能提供高层次的支持，但是，**它们并不依赖于具体的操作系统**。
  - `os`包中的 API 主要可以帮助我们使用操作系统中的文件系统、权限系统、环境变量、系统进程以及系统信号。
    - **其中，操纵文件系统的 API 最为丰富。**我们不但可以利用这些 API 创建和删除文件以及目录，还可以获取到它们的各种信息、修改它们的内容、改变它们的访问权限，等等。
    - 非常常用的数据类型：`os.File`

- `os.File`类型都实现了哪些`io`包中的接口

  - `os.File`类型拥有的都是指针方法，所以除了空接口之外，它本身没有实现任何接口。而它的指针类型则实现了很多`io`代码包中的接口。
  - 首先，对于`io`包中最核心的 3 个简单接口`io.Reader`、`io.Writer`和`io.Closer`，`*os.File`类型都实现了它们。
  - 其次，该类型还实现了另外的 3 个简单接口，即：`io.ReaderAt`、`io.Seeker`和`io.WriterAt`。
  - 正是因为`*os.File`类型实现了这些简单接口，所以它也顺便实现了`io`包的 9 个扩展接口中的 7 个。
    - 然而，由于**它并没有实现简单接口`io.ByteReader`和`io.RuneReader`**，所以它没有实现分别作为这两者的扩展接口的`io.ByteScanner`和`io.RuneScanner`。

- `os.File`类型能够以何种方式操作文件

  - 怎样才能获得一个`os.File`类型的指针值（以下简称`File`值）。

    - 在`os`包中，有这样几个函数，即：`Create`、`NewFile`、`Open`和`OpenFile`。

    - **`os.Create`函数用于根据给定的路径创建一个新的文件。** 它会返回一个`File`值和一个错误值。我们可以在该函数返回的`File`值之上，对相应的文件进行读操作和写操作

      - 注意，如果在我们给予`os.Create`函数的路径之上，已经存在了一个文件，那么该函数会先清空现有文件中的全部内容，然后再把它作为第一个结果值返回。
      - **另外，`os.Create`函数是有可能返回非`nil`的错误值的。**
        - 比如，如果我们给定的路径上的某一级父目录并不存在，那么该函数就会返回一个`*os.PathError`类型的错误值，以表示“不存在的文件或目录”。

    - **`os.NewFile`函数。** 该函数在被调用的时候，**需要接受一个代表文件描述符的、`uintptr`类型的值，以及一个用于表示文件名的字符串值**。

      - 如果我们给定的文件描述符并不是有效的，那么这个函数将会返回`nil`，否则，它将会返回一个代表了相应文件的`File`值。

      - 注意，不要被这个函数的名称误导了，**它的功能并不是创建一个新的文件，而是依据一个已经存在的文件的描述符，来新建一个包装了该文件的`File`值。**

      - ```go
        file3 := os.NewFile(uintptr(syscall.Stderr), "/dev/stderr")
        if file3 != nil {
         defer file3.Close()
         file3.WriteString(
          "The Go language program writes the contents into stderr.\n")
        }
        ```

    - **`os.Open`函数会打开一个文件并返回包装了该文件的`File`值。** 然而，该函数只能以只读模式打开文件。换句话说，**我们只能从该函数返回的`File`值中读取内容，而不能向它写入任何内容。**

      - `os.Open`函数的功能是：以只读模式打开已经存在的文件。其根源就是它在调用`os.OpenFile`函数的时候，**只提供了一个单一的操作模式`os.O_RDONLY`**。

    - **`os.OpenFile`函数。** 这个函数其实是`os.Create`函数和`os.Open`函数的底层支持，它最为灵活。

      - 这个函数有 3 个参数，分别名为`name`、`flag`和`perm`。其中的**`name`指代的就是文件的路径**。而`flag`参数指的则是需要施加在文件描述符之上的模式，我在前面提到的只读模式就是这里的一个可选项
      - 为了加以区别，我们把**参数`flag`指代的模式叫做操作模式，而把参数`perm`指代的模式叫做权限模式。**
      - 

  - 所谓的**文件描述符**，是由通常很小的非负整数代表的。**它一般会由 I/O 相关的系统调用返回，并作为某个文件的一个标识存在**。

    - 实际上，我们在调用前文所述的`os.Create`函数、`os.Open`函数以及将会提到的`os.OpenFile`函数的时候，它们都会执行同一个系统调用，并且在成功之后得到这样一个文件描述符。**这个文件描述符将会被储存在它们返回的`File`值中。**

- 可应用于`File`值的操作模式都有哪些

  - 针对`File`值的操作模式主要有**只读模式、只写模式和读写模式**。
    - 这些模式分别由常量`os.O_RDONLY`、`os.O_WRONLY`和`os.O_RDWR`代表。在我们新建或打开一个文件的时候，必须把这三个模式中的一个设定为此文件的操作模式。
  - 除此之外，我们还可以为这里的文件设置**额外的操作模式**，可选项如下所示。
    - `os.O_APPEND`：当向文件中写入内容时，把新内容追加到现有内容的后边。
    - `os.O_CREATE`：当给定路径上的文件不存在时，创建一个新文件。
    - `os.O_EXCL`：需要与`os.O_CREATE`一同使用，表示在给定的路径上不能有已存在的文件。
    - `os.O_SYNC`：在打开的文件之上实施同步 I/O。它会保证读写的内容总会与硬盘上的数据保持同步。
    - `os.O_TRUNC`：如果文件已存在，并且是常规的文件，那么就先清空其中已经存在的任何内容。

- 怎样设定常规文件的访问权限

  - `os.OpenFile`函数的第三个参数`perm`代表的是权限模式，其类型是`os.FileMode`。但实际上，`os.FileMode`类型能够代表的，可远不只**权限模式**，它还可以代表**文件模式**（也可以称之为文件种类）。
  - 实际上，在一个`os.FileMode`类型的值（以下简称`FileMode`值）中，**只有最低的 9 个比特位才用于表示文件的权限。**当我们拿到一个此类型的值时，**可以把它和`os.ModePerm`常量的值做按位与操作。**
    - 这个常量的值是`0777`，是一个八进制的无符号整数，其最低的 9 个比特位上都是`1`，而更高的 23 个比特位上都是`0`。
    - 所以，经过这样的按位与操作之后，我们即可得到这个`FileMode`值中所有用于表示文件权限的比特位，也就是该值所表示的权限模式。这将会与我们调用`FileMode`值的`Perm`方法所得到的结果值是一致。
  - 在这 9 个用于表示文件权限的比特位中，每 3 个比特位为一组，共可分为 3 组。
    - 从高到低，这 3 组分别表示的是文件所有者（也就是创建这个文件的那个用户）、文件所有者所属的用户组，以及其他用户对该文件的访问权限。而对于每个组，其中的 3 个比特位从高到低分别表示读权限、写权限和执行权限。

- 怎样通过`os`包中的 API 创建和操纵一个系统进程

  - 你可以从`os`包的`FindProcess`函数和`StartProcess`函数开始。前者用于通过进程 ID（pid）查找进程，后者用来基于某个程序启动一个进程。
  - 这两者都会返回一个`*os.Process`类型的值。该类型提供了一些方法，比如，用于杀掉当前进程的`Kill`方法，又比如，可以给当前进程发送系统信号的`Signal`方法，以及会等待当前进程结束的`Wait`方法。





# 访问网络服务

- 所谓 socket，是一种 IPC 方法。IPC 是 Inter-Process Communication 的缩写，可以被翻译为进程间通信。
- Go 语言对 IPC 也提供了一定的支持。
  - 比如，在`os`代码包和`os/signal`代码包中就有针对系统信号的 API。
  - 又比如，`os.Pipe`函数可以创建命名管道，而`os/exec`代码包则对另一类管道（匿名管道）提供了支持。
  - **对于 socket，Go 语言与之相应的程序实体都在其标准库的`net`代码包中。**
- 在 Linux 操作系统中，用于创建 socket 实例的 API，就是由一个名为`socket`的系统调用代表的。这个系统调用是 Linux 内核的一部分。
  - 在 Go 语言标准库的**`syscall`代码包**中，有一个与这个`socket`系统调用相对应的函数。这两者的函数签名是基本一致的，它们都会接受三个`int`类型的参数，并会返回一个可以代表文件描述符的结果。
  - 但不同的是，`syscall`包中的`Socket`函数本身是平台不相关的。**在其底层，Go 语言为它支持的每个操作系统都做了适配**，这才使得这个函数无论在哪个平台上，总是有效的。
  - **Go 语言的`net`代码包中的很多程序实体，都会直接或间接地使用到`syscall.Socket`函数。**
    - 比如，我们在调用`net.Dial`函数的时候，会为它的两个参数设定值。其中的第一个参数名为`network`，它决定着 Go 程序在底层会创建什么样的 socket 实例，并使用什么样的协议与其他程序通信。
- `syscall.Socket`函数接受的那三个参数。
  - 这个函数接受的三个参数都是`int`类型的。这些参数所代表的分别是想要创建的 **socket 实例通信域、类型以及使用的协议**。
    - Socket 的通信域主要有这样几个可选项：IPv4 域、IPv6 域和 Unix 域。
      - 以上三种通信域分别可以由`syscall`代码包中的常量`AF_INET`、`AF_INET6`和`AF_UNIX`表示。
    - Socket 的类型一共有 4 种，分别是：`SOCK_DGRAM`、`SOCK_STREAM`、`SOCK_SEQPACKET`以及`SOCK_RAW`。`syscall`代码包中也都有同名的常量与之对应。前两者更加常用一些。
      - `SOCK_DGRAM`中的“DGRAM”代表的是 datagram，即数据报文。它是一种有消息边界，但没有逻辑连接的非可靠 socket 类型，我们熟知的基于 UDP 协议的网络通信就属于此类。
      - 而`SOCK_STREAM`这个 socket 类型，恰恰与`SOCK_DGRAM`相反。**它没有消息边界，但有逻辑连接，能够保证传输的可靠性和数据的有序性，同时还可以实现数据的双向传输。**众所周知的基于 TCP 协议的网络通信就属于此类。
    - 通常，只要明确指定了前两个参数的值，我们就无需再去确定第三个参数值了，一般把它置为`0`就可以了。这时，内核程序会自行选择最合适的协议。
- `net.Dial`函数的第一个参数`network`有哪些可选值
  - `net.Dial`函数会接受两个参数，分别名为`network`和`address`，都是`string`类型的。
  - **参数`network`常用的可选值一共有 9 个。这些值分别代表了程序底层创建的 socket 实例可使用的不同通信协议**，罗列如下。
    - `"tcp"`：代表 TCP 协议，其基于的 IP 协议的版本根据参数`address`的值自适应。
    - `"tcp4"`：代表基于 IP 协议第四版的 TCP 协议。
    - `"tcp6"`：代表基于 IP 协议第六版的 TCP 协议。
    - `"udp"`：代表 UDP 协议，其基于的 IP 协议的版本根据参数`address`的值自适应。
    - `"udp4"`：代表基于 IP 协议第四版的 UDP 协议。
    - `"udp6"`：代表基于 IP 协议第六版的 UDP 协议。
    - `"unix"`：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_STREAM 为 socket 类型。
    - `"unixgram"`：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_DGRAM 为 socket 类型。
    - `"unixpacket"`：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_SEQPACKET 为 socket 类型。
- 调用`net.DialTimeout`函数时给定的超时时间意味着什么
  - 简单来说，这里的超时时间，**代表着函数为网络连接建立完成而等待的最长时间**。这是一个相对的时间。它会由这个函数的参数`timeout`的值表示。
  - 开始的时间点几乎是我们调用`net.DialTimeout`函数的那一刻。在这之后，时间会主要花费在“解析参数`network`和`address`的值”，以及“创建 socket 实例并建立网络连接”这两件事情上。
  - **值得注意的是，在解析`address`的值的时候，函数会确定网络服务的 IP 地址、端口号等必要信息，并在需要时访问 DNS 服务。**
  - 在`net`包中还有一个名为**`Dialer`的结构体类型**。该类型有一个名叫`Timeout`的字段，它与上述的`timeout`参数的含义是完全一致的。实际上，`net.DialTimeout`函数正是利用了这个类型的值才得以实现功能的。
- 在你调用了`net.Dial`等函数之后，如果成功就会得到一个代表了网络连接的`net.Conn`接口类型的值。我的问题是：**怎样在`net.Conn`类型的值上正确地设定针对读操作和写操作的超时时间**
  - net.Conn接口提供了SetDeadline, SetReadDeadline, SetWriteDeadline；调用SetDeadline方法等于同时调用了后两个方法，因为其最总调用的setDeadlineImpl(fd, t, 'r'+'w') 对读和写都设置了超时时间。



# 基于HTTP协议的网络服务

- 如果我们只是访问基于 HTTP 协议的网络服务的话，那么使用`net/http`代码包中的程序实体来做，显然会更加便捷。

  - `http.Get`函数会返回两个结果值。第一个结果值的**类型是`*http.Response`**，它是网络服务给我们传回来的响应内容的结构化表示。第二个结果值是**`error`类型**的，它代表了在创建和发送 HTTP 请求，以及接收和解析 HTTP 响应的过程中可能发生的错误。

  - `http.Get`函数会在内部使用缺省的 HTTP 客户端，并且调用它的`Get`方法以完成功能。这个缺省的 HTTP 客户端是由`net/http`包中的公开变量`DefaultClient`代表的，其类型是`*http.Client`。

    - ```go
      var httpClient1 http.Client
      resp2, err := httpClient1.Get(url1)
      
      // 与前面的这一行代码
      
      resp1, err := http.Get(url1)
      ```

- `http.Client`类型中的`Transport`字段代表着什么

  - `http.Client`类型中的`Transport`字段代表着：向网络服务发送 HTTP 请求，并从网络服务接收 HTTP 响应的操作过程。也就是说，**该字段的方法`RoundTrip`应该实现单次 HTTP 事务（或者说基于 HTTP 协议的单次交互）需要的所有步骤。**
  - **这个字段是`http.RoundTripper`接口类型的**，**它有一个由`http.DefaultTransport`变量代表的缺省值**（以下简称`DefaultTransport`）。当我们在初始化一个`http.Client`类型的值（以下简称`Client`值）的时候，如果没有显式地为该字段赋值，那么这个`Client`值就会直接使用`DefaultTransport`。
  - **`http.Client`类型的`Timeout`字段**，代表的正是前面所说的单次 HTTP 事务的**超时时间**，它是`time.Duration`类型的。

- `Transport`字段

  - `http.Transport`类型，会在内部使用一个`net.Dialer`类型的值（以下简称`Dialer`值），并且，它会把该值的`Timeout`字段的值，设定为`30`秒。
  - 也就是说，这个`Dialer`值如果在 30 秒内还没有建立好网络连接，那么就会被判定为操作超时。
  - `http.Transport`类型还包含了很多其他的字段，其中有一些字段是关于操作超时的。即：IdleConnTimeout、ResponseHeaderTimeout、ExpectContinueTimeout、TLSHandshakeTimeout。
  - 此外，还有一些与`IdleConnTimeout`相关的字段值得我们关注，即：`MaxIdleConns`、`MaxIdleConnsPerHost`以及`MaxConnsPerHost`。

- `http.Server`类型的`ListenAndServe`方法都做了哪些事情

  - `http.Server`类型与`http.Client`是相对应的。`http.Server`代表的是基于 HTTP 协议的服务端，或者说网络服务。
  - `http.Server`类型的`ListenAndServe`方法的功能是：**监听一个基于 TCP 协议的网络地址，并对接收到的 HTTP 请求进行处理。**这个方法会默认开启针对网络连接的存活探测机制，以保证连接是持久的。同时，该方法会一直执行，直到有严重的错误发生或者被外界关掉。当被外界关掉时，它会返回一个由`http.ErrServerClosed`变量代表的错误值。
  - 这个**`ListenAndServe`方法**主要会做下面这几件事情。
    1. **检查当前的`http.Server`类型的值（以下简称当前值）的`Addr`字段**。该字段的值代表了当前的网络服务需要使用的网络地址，即：IP 地址和端口号. 如果这个字段的值为空字符串，那么就用`":http"`代替。也就是说，使用任何可以代表本机的域名和 IP 地址，并且端口号为`80`。
    2. 通过调用`net.Listen`函数**在已确定的网络地址上启动基于 TCP 协议的监听**。
    3. **检查`net.Listen`函数返回的错误值。**如果该错误值不为`nil`，那么就直接返回该值。否则，通过调用当前值的`Serve`方法准备接受和处理将要到来的 HTTP 请求。

- 可以从当前问题直接衍生出的问题一般有两个，一个是“`net.Listen`函数都做了哪些事情”，另一个是“`http.Server`类型的`Serve`方法是怎样接受和处理 HTTP 请求的”。

  - **对于第一个直接的衍生问题，如果概括地说，回答可以是：**
    1. **解析**参数值中包含的网络地址隐含的 **IP 地址和端口号**；
    2. 根据给定的网络协议，确定监听的方法，并开始进行**监听**。
  - **对于第二个直接的衍生问题，我们可以这样回答：**
    - 在一个**`for`循环**中，网络监听器的**`Accept`方法**会被不断地调用，该方法会返回两个结果值；第一个结果值是**`net.Conn`类型**的，它会代表包含了新到来的 HTTP 请求的**网络连接**；第二个结果值是代表了可能发生的**错误的`error`类型值。**
    - 如果这里的`Accept`方法没有返回非`nil`的错误值，那么这里的程序将会先把它的第一个**结果值包装成一个`*http.conn`类型的值**（以下简称`conn`值），然后**通过在新的 goroutine 中调用这个`conn`值的`serve`方法，来对当前的 HTTP 请求进行处理。**

- 怎样优雅地停止基于 HTTP 协议的网络服务程序

  - `net/http.Server`类型有一个名为**`Shutdown`的指针方法**可以实现“优雅的停止”。也就是说，它可以在不中断任何正处在活动状态的连接的情况下平滑地关闭当前的服务器。
  - **它会先关闭所有的空闲连接，并一直等待。只有活动的连接变为空闲之后，它才会关闭它们。**当所有的连接都被平滑地关闭之后，它会关闭当前的服务器并返回。当有错误发生时，它还会把相应的错误值返回。
  - 另外，你还可以通过调用`Server`值的**`RegisterOnShutdown`方法来注册可以在服务器即将关闭时被自动调用的函数。**
  - 更确切地说，**当前服务器的`Shutdown`方法会以异步的方式调用如此注册的所有函数。**我们可以利用这样的函数来通知长连接的客户端“连接即将关闭”。


























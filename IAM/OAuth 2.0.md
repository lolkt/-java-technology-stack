# OAuth 2.0是要通过什么方式解决什么问题

- 用一句话总结来说，OAuth 2.0 就是一种授权协议

  - 互联网中所有的受保护资源，几乎都是以 Web API 的形式来提供访问的，当你使用微信登录其他网站或者 App 的时候，当你开始使用某个小程序的时候，你都在无感知的情况下用到了 OAuth 2.0
  - **OAuth 2.0 这种授权协议，就是保证第三方（软件）只有在获得授权之后，才可以进一步访问授权者的数据**
  - 在 OAuth 2.0 的体系里面有 4 种角色，按照官方的称呼它们分别是资源拥有者、客户端、授权服务和受保护资源。不过，这里的客户端，我更愿意称其为第三方软件
    - 资源拥有者 -> 小明，第三方软件 ->小兔软件，授权服务 -> 京东商家开放平台的授权服务，受保护资源 -> 小明店铺在京东上面的订单

- OAuth 2.0 授权的核心就是颁发访问令牌、使用访问令牌

  - 主要的动作，就是生成授权码–> 生成访问令牌–> 使用访问令牌

  

# 授权码许可类型中，为什么一定要有授权码

- 授权码许可（Authorization Code）类型。它是 OAuth 2.0 中最经典、最完备、最安全、应用最广泛的许可类型。

- 授权码许可类型的序列

  - ![img](https://img2020.cnblogs.com/blog/1279115/202009/1279115-20200928092051778-577067993.png)
  - ![img](https://img2020.cnblogs.com/blog/1279115/202009/1279115-20200928092314889-458660107.png)
    - 如果这里直接返回访问令牌，那我们肯定不能使用重定向的方式。因为**这样会把安全保密性要求极高的访问令牌暴露在浏览器上**
    - **当小明被浏览器重定向到授权服务上之后，小明跟小兔软件之间的 “连接” 就断了**。问号处的时序上，小明再也没有重新“连接”到小兔软件。

  - 在授权码许可的流程中，为什么需要两次重定向
    - 为了重新建立起这样的一次连接，我们又不能让访问令牌暴露出去，就有了这样一个**临时的、间接的凭证：授权码**。因为小兔软件最终要拿到的是安全保密性要求极高的访问令牌，并不是授权码，而授权码是可以暴露在浏览器上面的。这样有了授权码的参与，访问令牌可以在后端服务之间传输，同时呢还可以重新建立小明与小兔软件之间的“连接”。这样通过一个授权码，既“照顾”到了小明的体验，又“照顾”了通信的安全。

- 授权码许可类型的通信过程

  - 间接通信就是指获取授权码的交互，而直接通信就是指通过授权码换取访问令牌的交互。

  - 间接通信

    > 小明：“你好，小兔软件，我要访问你了。”
    >
    > 小兔软件：“好的，我把你引到授权服务那里，我需要授权服务给我一个授权码。”
    >
    > 授权服务：“小兔软件，**我把授权码发给浏览器了**。”
    >
    > 小兔软件：“好的，我从浏览器拿到了授权码。”

    - 第三方软件小兔和授权服务之间，并没有发生直接的通信，而是**通过浏览器这个“中间人” 来 “搭线”的**。因此，我们说这是一个间接通信的方式。

  - 直接通信

    - 就是第三方软件小兔获取到授权码 code 值后，向授权服务发起获取访问令牌 access_token 的通信请求。这个请求是第三方软件服务器跟授权服务的服务器之间的通信。

- 两两站队

  - OAuth 2.0 中的 4 个角色是 “两两站队” 的：资源拥有者和第三方软件“站在一起”，因为第三方软件要代表资源拥有者去访问受保护资源；授权服务和受保护资源“站在一起”，因为授权服务负责颁发访问令牌，受保护资源负责接收并验证访问令牌。

- 一定要有浏览器吗
  - 根据微信官方文档描述，开发者获取用户登录态信息的过程正是一个授权码的许可流程：
    - 首先，开发者通过 wx.login(Object object) 方法获取到登录凭证 code 值，这一步的流程是在小程序内部通过调用微信提供的 SDK 实现；
    - 然后，再通过该 code 值换取用户的 session_key 等信息，也就是官方文档的auth.code2Session 方法，同时该方法也是被强烈建议通过开发者的后端服务来调用的。
  - 先通过小程序前端获取到 code 值，再通过小程序的后端服务使用 code 值换取 session_key 等信息，只不过是访问令牌 access_token 的值被换成了 session_key。



# 授权码和访问令牌的颁发流程

- 授权服务的工作过程

  - 在授权码许可类型中，授权服务的工作，可以划分为两大部分，一个是**颁发授权码 code**，一个是**颁发访问令牌 access_token**。
  - ![img](https://img2020.cnblogs.com/blog/1279115/202009/1279115-20200928144428813-2096455295.png)

- **过程一：颁发授权码** **code**

  - 在这个过程中，授权服务需要完成两部分工作，分别是**准备工作**和**生成授权码 code**。
  - **第一步，验证基本信息。**
    - 验证基本信息，包括对第三方软件小兔合法性和回调地址合法性的校验。
    - 在授权服务的程序中，这两步验证通过后，就会生成或者响应一个页面（**属于授权服务器上的页面**），以提示小明进行授权。
  - **第二步，验证权限范围（第一次）。**
    - 当小明为小兔进行授权的时候，也可以选择给小兔的权限范围，比如是否授予小兔获取 3 个月以前的订单的访问权限。
    - 这就意味着，我们需要对小兔传过来的 scope 参数，与小兔注册时申请的权限范围做比对。如果请求过来的权限范围大于注册时的范围，就需要作出越权提示。**记住，此刻是第一次权限校验。**
  - **第三步，生成授权请求页面。**
    - 至此，颁发授权码 code 的准备工作就完成了。
    - 当用户点击授权按钮“approve”后，才会**生成授权码 code 值和访问令牌acces_token 值**，“一切才真正开始”。

  - **第四步，验证权限范围（第二次）。**
    - 在步骤二中，生成授权页面之前授权服务进行的第一次校验，是对比小兔请求过来的权限范围 scope 和注册时的权限做的比对。这里的第二次验证权限范围，是用小明进行授权之后的权限，再次与小兔软件注册的权限做校验。
  - **第五步，处理授权请求，生成授权码 code。**
    - 在授权服务中，需要将生成的授权码 code 值与 app_id、user 进行关系映射。
    - 我们还需要为 code 设置一个有效期。OAuth 2.0 规范建议授权码 code 值有效期为 10 分钟，并且**一个授权码 code 只能被使用一次**。
    - 同时，授权服务还需要**将生成的授权码 code 跟已经授权的权限范围 rscope 进行绑定并存储**，以便后续颁发访问令牌时，我们能够通过 code 值取出授权范围并与访问令牌绑定。
  - **第六步，重定向至第三方软件。**
    - 生成授权码 code 值之后，授权服务需要将该 code 值告知第三方软件小兔。开始时我们提到，颁发授权码 code 是通过前端通信完成的，因此这里采用重定向的方式。
  - 到此，颁发授权码 code 的流程全部完成。当小兔获取到授权码 code 值以后，就可以开始请求访问令牌 access_token 的值了，也就是我们即将开始的过程二。

- **过程二：颁发访问令牌** **access_token**

  - 授权码只是一个换取访问令牌 access_token 的临时凭证。
  - 当小兔拿着授权码 code 来请求的时候，授权服务需要为之生成最终的请求访问令牌。这个过程主要包括验证第三方软件小兔是否存在、验证 code 值是否合法和生成access_token 值这三大步。
  - **第一步，验证第三方软件是否存在。**
    - 由于颁发访问令牌是通过后端通信完成的，所以这里除了要校验 app_id 外，还要校验app_secret。
  - **第二步，验证授权码 code 值是否合法。**
    -  这里我们一定要记住，**确认过授权码 code 值有效以后，应该立刻从存储中删除当前的code 值**，以防止第三方软件恶意使用一个失窃的授权码 code 值来请求授权服务。
  - **第三步，生成访问令牌 access_token 值。**
    - 关于按照什么规则来生成访问令牌 access_token 的值，OAuth 2.0 规范中并没有明确规定，但必须符合三个原则：**唯一性、不连续性、不可猜性**。
    - 和授权码 code 值一样，我们需要将访问令牌 access_token 值存储起来，并将其与第三方软件的应用标识 app_id 和资源拥有者标识 user 进行关系映射。也就是说，**一个访问令牌access_token 表示某一个用户给某一个第三方软件进行授权**。
    - 同时，**授权服务还需要将授权范围跟访问令牌 access_token 做绑定**。最后，还需要为该访问令牌设置一个过期时间 expires_in，比如 1 天。
    - 将一些必要的信息通过结构化的处理放入令牌本身。**我们将包含了一些信息的令牌，称为结构化令牌，简称 JWT**

- 刷新令牌

  - **颁发刷新令牌**
    - 其实，颁发刷新令牌和颁发访问令牌是一起实现的，都是在过程二的步骤三生成访问令牌access_token 中生成的。
    - 刷新令牌存在的初衷是，在访问令牌失效的情况下，为了不让用户频繁手动授权，用来通过系统重新请求**生成一个新的访问令牌**。
  - **使用刷新令牌**
    - 在授权服务的代码里，当我们接收到这种授权许可请求的时候，会先比较 grant_type 和 refresh_token 的值，然后做下一步处理。
    - **第一步，接收刷新令牌请求，验证基本信息。**
      - 和颁发访问令牌前的验证流程一样，这里我们也需要验证第三方软件是否存在。需要注意的是，这里需要同时验证刷新令牌是否存在
      - 另外，我们还需要验证刷新令牌是否属于该第三方软件。授权服务是将颁发的刷新令牌与第三方软件、当时的授权用户绑定在一起的，因此这里需要判断该刷新令牌的归属合法性。
      - **需要注意，一个刷新令牌被使用以后，授权服务需要将其废弃，并重新颁发一个刷新令牌**
    - **第二步，重新生成访问令牌。**

- 总结

  - 授权服务的核心就是，**先颁发授权码 code 值，再颁发访问令牌 access_token 值**。
  - 在颁发访问令牌的**同时还会颁发刷新令牌 refresh_token 值，这种机制可以在无须用户参与的情况下用于生成新的访问令牌**。
  - 授权还要有授权范围，**不能让第三方软件获得比注册时权限范围还大的授权，也不能获得超出了用户授权的权限范围，始终确保最小权限安全原则。**



# OAuth2.0中如何使用JWT结构化令牌

- **令牌内检**
  - 授权服务和受保护资源服务，它俩是“一伙的”。受保护资源来调用授权服务提供的检验令牌的服务，**我们把这种校验令牌的方式称为令牌内检。**
  - 具体到 OAuth 2.0 的授权流程中，JWT 令牌是如何被使用的呢
    - 授权服务“扔出”一个令牌，受保护资源服务“接住”这个令牌，然后自己开始解析令牌本身所包含的信息就可以了，而不需要再去查询数据库或者请求 RPC 服务。
    - 实际上，授权服务颁发了 JWT 令牌后给到了小兔软件，小兔软件拿着 JWT 令牌来请求受保护资源服务，也就是小明在京东店铺的订单。很显然，JWT 令牌需要在公网上做传输。所以**在传输过程中，JWT 令牌需要进行 Base64 编码以防止乱码，同时还需要进行签名及加密处理来防止数据信息泄露。**
- 为什么要使用 JWT 令牌？
  - 优点
    - JWT 的核心思想，就是用计算代替存储，有些 “时间换空间” 的 “味道”。
    -  JWT 令牌内部已经包含了重要的信息，所以在整个传输过程中都必须被要求是密文传输的，**这样被强制要求了加密也就保障了传输过程中的安全性**。
    - **使用 JWT 格式的令牌，有助于增强系统的可用性和可伸缩性**。这种 JWT 格式的令牌，通过“自编码”的方式包含了身份验证需要的信息，不再需要服务端进行额外的存储，所以每次的请求都是无状态会话。
  - 缺点
    - 没办法在使用过程中修改令牌状态。
    - 使用 JWT 格式令牌时，每次颁发的令牌都不会在服务端存储
      - 两种建议，**一种是建立一个秘钥管理系统，将生成秘钥的粒度缩小到用户级别，另外一种是直接将用户密码当作密钥。**



# 如何安全、快速地接入OAuth 2.0

- **构建第三方软件应用**
  - 这些内容包括 4 部分，分别是：**注册信息、引导授权、使用访问令牌、使用刷新令牌。**
- **构建受保护资源服务**
  - 权限范围
    - 不同的权限对应不同的操作
    - 不同的权限对应不同的数据
    - 不同的用户对应不同的数据
  - 为了应对这种情况，我们应该有一个统一的网关层来处理这样的校验，所有的请求都会经过 API GATEWAY 跳转到不同的受保护资源服务。这样呢，我们就不需要在每一个受保护资源服务上都做一遍权限校验的工作了，而只需要在 API GATEWAY 这一层做权限校验就可以了。



# OAuth 2.0还支持什么授权流程

- 资源拥有者凭据许可
  - 从“资源拥有者凭据许可”这个命名上，你可能就已经理解它的含义了。没错，资源拥有者的凭据，就是用户的凭据，就是用户名和密码。
  - 小兔此时就是京东官方出品的一款软件，小明也是京东的用户，那么小明其实是可以使用用户名和密码来直接使用小兔这款软件的。原因很简单，那就是**这里不再有“第三方”的概念了。**
  - 通过资源拥有者的用户名和密码获取access_token。
  - 这种许可类型的流程
    - ![img](https://img2020.cnblogs.com/blog/1279115/202009/1279115-20200928153815790-1528682934.png)
- 客户端凭据许可
  - 如果没有明确的资源拥有者，换句话说就是，小兔软件访问了一个不需要用户小明授权的数据。**你也可以形象地理解为 “资源拥有者被塞进了第三方软件中” 或者 “第三方软件就是资源拥有者**
  - 因为授权过程没有了资源拥有者小明的参与，小兔软件的后端服务可以随时发起 access_token 的请求，所以这种授权许可也不需要刷新令牌。
  - 通过第三方软件的app_id和app_secret获取access_token。







# 如何在移动App中使用OAuth 2.0

todo







# 实践OAuth 2.0时，使用不当可能会导致哪些安全漏洞

- 5个典型的安全问题，其中 CSRF、XSS、水平越权这三种是互联网环境下常见的安全风险，**授权码失窃和重定向 URI 被篡改属于 OAuth2.0“专属”的安全风险。**
- CSRF攻击
  - 恶意软件让浏览器向**已完成用户身份认证**的网站发起请求，并**执行有害的操作**，就是跨站请求伪造攻击。
- XSS攻击
  - XSS 攻击的主要手段是将恶意脚本注入到请求的输入中，攻击者可以通过注入的恶意脚本来进行攻击行为，比如搜集数据等。
- 水平越权
  - 水平越权是指，在请求受保护资源服务数据的时候，服务端应用程序未校验这条数据是否归属于当前授权的请求用户。
  - 发生水平越权问题的根本原因，还是开发人员的认知与意识不够。
- 授权码失窃
  - 如果有一个用户 G 对第三方软件 B，进行授权并产生了一个授权码codeB，但并没有对攻击者软件 A 授权。此时，软件 A 是不能访问用户 G 的所有数据的。但这时，如果软件 A 获取了这个 codeB，是不是就能够在没有获得用户 G 授权的情况下访问用户 G 的数据了
  - **这时问题的根源就在于两点**
    - 授权服务在进行授权码校验的时候，没有校验 app_id_B；
    - 软件 B使用过一次 codeB 的值之后，授权服务没有删除这个codeB；
  - 看到这里，通过校验 app_id_B，并删除掉使用过一次的授权码及其对应的访问令牌，就可以从根本上来杜绝授权码失窃带来的危害了。
- 重定向 URI 被篡改
  - 有的时候，授权服务提供方并没有对第三方软件的回调 URI 做完整性要求和完整性校验。
  - 只要我们在授权服务验证第三方软件的请求时做了签名校验，那么攻击者在只拿到授权码 code 的情况下，仍然无法获取访问令牌，因为第三方软件只有通过访问令牌才能够访问用户的数据。





# 利用OAuth 2.0实现一个OpenID Connect用户身份认证协议

- OIDC是什么

  - 联合登录和单点登录它们其实都是 OpenID Connect（简称OIDC）的应用场景的实现。
  - **OIDC 其实就是一种用户身份认证的开放标准。**使用微信账号登录网站的场景，就是这种开放标准的实践。
    - **用微信登录某第三方软件，确实使用的是 OAuth 2.0。但 OAuth2.0 是一种授权协议，而不是身份认证协议。OIDC 才是身份认证协议，而且是基于 OAuth 2.0 来执行用户身份认证的互通协议。**更概括地说，OIDC 就是直接基于 OAuth 2.0 构建的身份认证框架协议。
  - 换种表述方式，**OIDC= 授权协议 + 身份认证**

- OIDC和OAuth 2.0的角色对应关系

  - OAuth 2.0 的授权码许可流程的运转，需要资源拥有者、第三方软件、授权服务、受保护资源这 4 个角色间的顺畅通信、配合才能够完成。
  -  OIDC 的三个主要角色
    - EU（End User），代表最终用户。
    - RP（Relying Party），代表认证服务的依赖方，就是第三方软件。
    - OP（OpenID Provider），代表提供身份认证服务方。
  - 现在很多 App 都接入了微信登录，那么微信登录就是一个大的身份认证服务（OP）（授权服务、受保护资源）。一旦我们有了微信账号，就可以登录所有接入了微信登录体系的 App（RP），这就是我们常说的联合登录。

- OIDC和OAuth 2.0的关键区别

  -  OIDC 的通信流程图
    - ![img](https://img2020.cnblogs.com/blog/1279115/202009/1279115-20200928200704282-1209904453.png)
    - 一个基于授权码流程的 OIDC 协议流程，跟 OAuth 2.0 中的授权码许可的流程几乎完全一致，唯一的区别就是多返回了一个 **ID_TOKEN**，我们称之为 **ID 令牌**。这个令牌是身份认证的关键。

- OIDC 中的 ID 令牌生成和解析方法

  - ID 令牌是一个 JWT 格式的令牌，id_token是包含代表用户身份信息的声明，id_token的使命本身就是用来标识用户的。

  - 虽然 JWT 令牌是一种自包含信息体的令牌，为将其作为 ID 令牌带来了方便性，但是因为 ID 令牌需要能够标识出用户、失效时间等属性来达到身份认证的目的，所以要将其作为 OIDC 的 ID 令牌时，下面这 5 个 JWT 声明参数也是必须要有的。

  - > iss，令牌的颁发者，其值就是身份认证服务（OP）的 URL。
    >
    > sub，令牌的主题，其值是一个能够代表最终用户（EU）的全局唯一标识符。
    >
    > aud，令牌的目标受众，其值是三方软件（RP）的 app_id。
    >
    > exp，令牌的到期时间戳，所有的 ID 令牌都会有一个过期时间。
    >
    > iat，颁发令牌的时间戳。

  - 第三方软件解析并验证 ID 令牌的合法性之后，不需要将整个 JWT 信息保存下来，只需保留 JWT 中的 PAYLOAD（数据体）部分就可以了。因为正是这部分内容，包含了身份认证所需要的用户唯一标识等信息。

    - 另外，在验证 JWT 合法性的时候，因为 ID 令牌本身已经被身份认证服务（OP）的密钥签名过，所以关键的一点是合法性校验时需要做签名校验。
    - 这样当第三方软件（RP）拿到 ID 令牌之后，就已经获得了处理身份认证标识动作的信息，也就是拿到了那个能够唯一标识最终用户（EU）的 ID 值，比如 3521。

- 用访问令牌获取 ID 令牌之外的信息

  - **在保证用户身份认证功能的前提下，如果想获取更多的用户信息，就再通过访问令牌获取。**在OIDC 框架里，这部分内容叫做创建 UserInfo 端点和获取 UserInfo 信息。
    - 细粒度地去看 OIDC 的流程就是：**生成 ID 令牌 -> 创建 UserInfo 端点 ->解析 ID 令牌 -> 记录登录状态 -> 获取 UserInfo**。
    - 用 OAuth 2.0 实现 OIDC 的最关键的方法是：在原有 OAuth 2.0 流程的基础上增加 ID 令牌和 UserInfo 端点，以保障 OIDC 中的第三方软件能够记录用户状态和获取用户详情的功能。

- **单点登录**

  - 只需要让第三方软件（RP）重复我们 OIDC 的通信流程就可以了
    - ![img](https://img2020.cnblogs.com/blog/1279115/202009/1279115-20200928200724542-285882442.png)





# 基于OAuth 2.0/JWT的微服务参考架构

- 从单体到微服务架构的演进，是当前企业数字化转型的一大趋势。OAuth 2.0是当前业界标准的授权协议，它的核心是若干个针对不同场景的令牌颁发和管理流程；而JWT是一种轻量级、自包含的令牌，可用于在微服务间安全地传递用户信息。

- 假定有这样一家叫 ACME 的新零售公司

  - ![img](https://img2020.cnblogs.com/blog/1279115/202009/1279115-20200928222718666-1815608078.png)

- Web 应用层（网关之前）的安全机制主要基于OAuth 2.0 访问令牌实现（它是一种**透明令牌**或者称**引用令牌**），微服务层（网关之后）的安全机制主要基于 JWT 令牌实现（它是一种**不透明**的**自包含令牌**）。网关层在中间实现两种令牌的转换。这是一种 OAuth 2.0 访问令牌 +JWT 令牌的混合模式。

  - 之所以这样设计，是因为 Web 层靠近用户端，如果采用 JWT 令牌，会暴露用户信息，有一定的安全风险，所以采用 OAuth 2.0 访问令牌，它是一个无意义随机字符串。而在网关之后，安全风险相对低，同时很多服务需要用户信息，所以采用自包含用户信息的 JWT 令牌更合适。

- 微服务分层架构

  - 大致可以分为 Nginx 反向代理层、Web 应用层、Gateway 网关层、BEF 层和领域服务层，还包括一个 IDP 服务。
  - Nginx 反向代理层
    - Nginx 集群是整个平台的流量入口
    - 主要功能是实现反向路由，也就是将外部流量根据 HOST 主机头或者 PATH，路由到不同的后端，比方说路由到 Web 应用，或者直接到网关 Gateway。
    - 在 Kubernetes 体系中，Nginx 是和 Ingress Controller（入口控制器）配合工作的（总称为 Nginx Ingress），Ingress Controller 支持通过 Ingress Rules，配置 Nginx 的路由规则。
  -  Web 应用层，html/css/js 等资源就住在这一层。
    - Web 服务层通常采用传统的 Web MVC + 模版引擎方式处理，可以实现服务器端渲染，也可以采用单页 SPA 方式。这一层主要由公司的前端团队负责，通常会使用 Node.js 技术栈来实现，也可以采用 Spring MVC 技术栈实现。
  - Gateway 网关层
    - 这一层是微服务调用流量的入口。网关的主要职责是反向路由，也就是将前端请求根据HOST 主机头、或者 PATH、或者查询参数，路由到后端目标微服务
    - 网关还承担两个重要的安全职责
      - 一个是令牌的校验和转换，将前端传递过来的 OAuth 2.0 访问令牌，通过调用 IDP 进行校验，并转换为包含用户和权限信息的 JWT 令牌，再将 JWT 令牌向后台微服务传递。
      - 另外一个是权限校验，网关的路由表可以和 OAuth 2.0 的 Scope 进行关联。这样，网关根据请求令牌中的权限范围 Scope，就可以判断请求是否具有调用后台服务的权限。
    - 另外，网关还需承担集中式限流、日志监控，以及支持 CORS 等功能。
  - IDP 服务
    - 主要负责 OAuth 2.0 授权协议处理，OAuth 2.0 和JWT 令牌颁发和管理，以及用户认证等功能。
  - BFF 层
    - BFF 是 Backend for Frontend 的简称，主要实现对后台领域服务的聚合功能，同时为不同的前端体验（PC/Mobile/开放平台等）提供更友好的 API 和数据格式。
    - BFF 服务可以用 Node.js 开发，也可以用 Java/Spring 等框架开发。
  - 领域服务层
    - 领域服务层在整个微服务架构的底层。这些服务包含业务逻辑，通常有自己独立的数据库存储，还可以根据需要调用外部的服务。
    - 根据微服务分层原则，领域服务禁止调用其它的领域服务，更不允许反向调用 BFF 服务。
    - 这样做是为了保持微服务职责单一（Single Responsibility）和有界上下文（Bounded Context），避免复杂的领域依赖。领域服务是独立的开发、测试和发布单位。在电商领域，常见的领域服务有用户服务、商品服务、订单服务和支付服务等。
    - 可以看到，领域服务和 BFF 服务都是无状态的，它们本身并不存储用户状态，而是通过传递过来的 JWT 数据获取用户信息。所以在整个架构中，微服务都是无状态、可以按需水平扩展的，状态要么存在用户端（浏览器或者手机 App 中），要么存在集中的数据库中。

- OAuth 2.0/JWT 如何与微服务进行集成

  - 场景 1：第一方 Web 应用 + 资源拥有者凭据模式

    - 下面是流程说明

      1. 用户通过浏览器访问 ACME 公司的电商网站，点击登录链接。

      2. Web 应用返回登录界面（这个登录页可以是网站自己定制开发）。

      3. 用户输入用户名、密码进行认证。

      4. Web 应用将用户名、密码，通过网关转发到 IDP 的令牌获取端点（POST

      /oauth2/token，grant_type=password）。

      5. IDP 通过 Login Service 对用户进行认证。

      6. IDP 认证通过，返回有效访问令牌（根据需要也可以返回刷新令牌）。

      7. Web 应用接收到访问令牌，创建用户 Session，并将 OAuth 2.0 令牌保存其中，然后返回登录成功到用户端。

      8. 用户浏览器中记录 Session Cookie，登录成功。

    - 再来看看认证授权之后的服务调用流程。

      1. 用户登录后，在网站上点击查看自己的购物历史记录。

      2. Web 应用通过网关调用后台 API（查询用户的购物历史记录），请求 HTTP header 中带上 OAuth 2.0 令牌（来自用户 Session）。

      3. 网关截取 OAuth 2.0 令牌，去 IDP 进行校验。

      4. IDP 校验令牌通过，再通过令牌查询用户和 Scope 信息，构建 JWT 令牌，返回。

      5. 网关获得 JWT 令牌，校验 Scope 是否有权限调用 API，如果有就转发到后台 API 进行调用。

      6. 后台 BFF（或者领域服务）通过传递过来的 JWT 获取用户信息，根据用户 ID 查询购物历史记录，返回。

      7. Web 应用获得用户的购物历史数据，可以根据需要缓存在 Session 中，再返回用户端。

      8. 购物历史数据返回到用户浏览器端。

  - 场景3：第三方 Web 应用 + 授权码模式

    - 某第三方合作厂商开发了一个 Web 网站，要访问 ACME 公司的电商开放平台 API。这是一个第三方 Web 应用场景，通常选用 OAuth 2.0 的授权码许可模式。

    - 认证授权的流程

      1. 用户访问这个第三方 Web 应用，点击登录链接。

      2. Web 应用后台向 ACME 公司的 IPD 服务发送申请授权码请求（GET /authorize）。

      3. 用户被重定向到 ACME 公司的 IDP 统一登录页面。

      4. 用户进行认证和授权。

      5. IDP 通过 Login Service 对用户进行认证。

      6. 认证和授权通过，IDP 返回授权码。

      7. Web 应用获得授权码，再向 IDP 服务的令牌获取端点发起请求（POST/oauth2/token, grant_type=authorization-code）。

      8. IDP 校验授权码，校验通过则返回有效 OAuth 2.0 令牌（根据需要也可以返回刷新令牌）。

      9. Web 应用创建用户 Session，将 OAuth 2.0 令牌保存在 Session 中，然后返回登录成功到用户端。

      10. 用户浏览器中记录 Session Cookie，登录成功。

    - 之后，第三方 Web 应用如果需要和 ACME 电商平台交互，可直接通过网关调用微服务，请求 HTTP header 中带上 OAuth 2.0 访问令牌即可。后续的服务调用流程，和前面的“第一方应用 + 资源拥有者凭据模式”类似。

    



# 各大开放平台是如何使用OAuth 2.0的

- 我们再以用户小明使用小兔打单软件为例，来看看这些系统角色之间具体又是怎样交互的
  - ![](https://img2020.cnblogs.com/blog/1279115/202009/1279115-20200929110444629-367891925.png)
  - 当有了 API 网关这一层的时候，这些校验工作就会都落到了 API 网关的身上，因为我们不能让很多个受保护资源服务做同样的事情（验证访问令牌或者第三方软件应用信息）。
- **授权码流程中的参数说明**
  - 概括来讲，在京东商家开放平台的授权服务这一侧，提供服务的就是两个端点：负责生成授权码的**授权端点**以及负责颁发访问令牌的**令牌端点**。整个授权过程中，虽然看着有很多参数，但你可以围绕这两条线，来对它们做归类。
  - 小明在使用小兔打单软件的时候，首先被小兔通过重定向的方式引导到京东商家开放平台的授权服务上，其实就是引导到了授权服务的授权端点上。这个重定向的过程中用到的参数如下
    - ![](https://img2020.cnblogs.com/blog/1279115/202009/1279115-20200929110454145-1836060723.png)
    - OAuth 2.0 官方建议的避免 CSRF 攻击的方式，就是使用 state 参数
  - 接着，京东商家开放平台授权服务的授权端点，会向小兔软件做出响应。这个响应的过程用到的基本参数，如下
    - ![](https://img2020.cnblogs.com/blog/1279115/202009/1279115-20200929110456712-200523967.png)
    - 对于授权码 code 的值，一般建议的最长生命周期是 10 分钟。另外，小兔打单软件只能被允许使用一次该授权码的值，如果使用一次之后还用同样的授权码值来请求，授权服务必须拒绝。
    - 对于这次的 state 值，授权服务每次都是必须要返回给小兔打单软件的。无论小兔打单软件在起初的时候有没有发送该值，都必须返回回去，如果没有就返回空。这样当小兔打单软件日后升级增加该值的时候，京东商家开放平台就不需要改动任何代码逻辑了。
  - 在拿到授权码 code 的值之后，接下来就是小兔打单软件向京东商家开放平台的授权服务的令牌端点发起请求，申请访问令牌。这个过程中需要传递的基本参数，如下
    - ![](https://img2020.cnblogs.com/blog/1279115/202009/1279115-20200929110501418-743524157.png)
  - 在授权服务接收到小兔打单软件申请访问令牌的请求后，像授权端点一样，令牌端点也需要向小兔打单软件做出响应。这个过程涉及到的基本参数，如下：
    - ![](https://img2020.cnblogs.com/blog/1279115/202009/1279115-20200929110508491-1624329165.png)
    - 对于这里返回的 scope 值，我要强调下，其实就是小兔软件被允许的实际的权限范围，因为小明有可能给小兔软件授予了小于它在开放平台注册时申请的权限范围。比如，小兔打单软件申请了查询历史订单、查询当天订单两个 API 的权限，但小明可能只给小兔授权了查询当天订单 API 的权限。


